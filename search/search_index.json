{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ceramic Docs \u00b6 Ceramic is the public dataweb. An open network for deploying and managing information. Ceramic public infrastructure serves as a secure, performant data storage backend. Version control, verifiability, Something about the linked document model, something about DIDs. Whether you're building a fully-featured application that needs to write documents to a mutable decentralized backend, hacking together a project that needs to query open information, or just want to experiment with next-generation Web3 and peer-to-peer technologies, our developer platform has the tools to support you. Quick start Installation Learn the basics \u00b6 Protocol Overview \u00b6 Document Model \u00b6 Network Design \u00b6 Decentralized ID \u00b6 Development Tools \u00b6 HTTP Client \u00b6 JS Client \u00b6 CLI Client \u00b6 API Reference \u00b6 Resources \u00b6 :octicons-octoface-16: Discord \u00b6 :octicons-octoface-16: Blog \u00b6 :octicons-octoface-16: Github \u00b6","title":"Ceramic Docs"},{"location":"#ceramic-docs","text":"Ceramic is the public dataweb. An open network for deploying and managing information. Ceramic public infrastructure serves as a secure, performant data storage backend. Version control, verifiability, Something about the linked document model, something about DIDs. Whether you're building a fully-featured application that needs to write documents to a mutable decentralized backend, hacking together a project that needs to query open information, or just want to experiment with next-generation Web3 and peer-to-peer technologies, our developer platform has the tools to support you. Quick start Installation","title":"Ceramic Docs"},{"location":"#learn-the-basics","text":"","title":"Learn the basics"},{"location":"#development-tools","text":"","title":"Development Tools"},{"location":"#resources","text":"","title":"Resources"},{"location":"learn/","text":"","title":"Learn"},{"location":"authentication/dids/3id/","text":"3ID DID \u00b6 3ID is one of a few DID methods supported by Ceramic that can be used to perform authenticated writes to streams that require DIDs. This includes the two default StreamTypes: Tile Documents and CAIP-10 Links. When 3IDs are used in conjunction with IDX and the 3ID Keychain (as is implemented in 3ID Connect), a 3ID can easily be controlled with any number of blockchain accounts from any L1 or L2 network. This provides a way to unify a user's identity across all other platforms. Usage \u00b6 See the Authentication page to learn how to use the 3ID DID method in your Ceramic project. Design \u00b6 The DID document for a 3ID is stored natively on Ceramic as a Tile Document StreamType, allowing for mutability and enabling it to securely handle key rotations. This is a desireable property particularly for end user DIDs. Additionally since 3ID is native to Ceramic, developers do not need to operate additional infrastructure or rely on other external technologies. See CIP-79 for the full technical specification of the 3ID DID method. Other DID methods \u00b6 Ceramic supports a few different DID methods for authentication. Below find links to the others: Key DID NFT DID (coming soon) Safe DID (coming soon)","title":"3ID DID"},{"location":"authentication/dids/3id/#3id-did","text":"3ID is one of a few DID methods supported by Ceramic that can be used to perform authenticated writes to streams that require DIDs. This includes the two default StreamTypes: Tile Documents and CAIP-10 Links. When 3IDs are used in conjunction with IDX and the 3ID Keychain (as is implemented in 3ID Connect), a 3ID can easily be controlled with any number of blockchain accounts from any L1 or L2 network. This provides a way to unify a user's identity across all other platforms.","title":"3ID DID"},{"location":"authentication/dids/3id/#usage","text":"See the Authentication page to learn how to use the 3ID DID method in your Ceramic project.","title":"Usage"},{"location":"authentication/dids/3id/#design","text":"The DID document for a 3ID is stored natively on Ceramic as a Tile Document StreamType, allowing for mutability and enabling it to securely handle key rotations. This is a desireable property particularly for end user DIDs. Additionally since 3ID is native to Ceramic, developers do not need to operate additional infrastructure or rely on other external technologies. See CIP-79 for the full technical specification of the 3ID DID method.","title":"Design"},{"location":"authentication/dids/3id/#other-did-methods","text":"Ceramic supports a few different DID methods for authentication. Below find links to the others: Key DID NFT DID (coming soon) Safe DID (coming soon)","title":"Other DID methods"},{"location":"authentication/dids/key/","text":"Key DID \u00b6 Key DID is one of a few DID methods supported by Ceramic that can be used to perform authenticated writes to streams that require DIDs. This includes the two default StreamTypes: Tile Documents and CAIP-10 Links. Usage \u00b6 See the Authentication page to learn how to use the Key DID method in your Ceramic project. Design \u00b6 The DID document for a Key DID is statically generated from any Ed25519 cryptographic key pair. This Ed25519 key is used to control the DID. Key DID is lightweight, but the main drawback is that its DID document is immutable and has no ability to rotate keys if it is compromised; it is explicitly tied to a single crypto key. This makes Key DIDs best suited for users who will only want to ever use one keypair to control their DID, and who have strong key security practices - such as a developer. Other DID methods \u00b6 Ceramic supports a few different DID methods for authentication. Below find links to the others: 3ID DID NFT DID (coming soon) Safe DID (coming soon)","title":"Key DID"},{"location":"authentication/dids/key/#key-did","text":"Key DID is one of a few DID methods supported by Ceramic that can be used to perform authenticated writes to streams that require DIDs. This includes the two default StreamTypes: Tile Documents and CAIP-10 Links.","title":"Key DID"},{"location":"authentication/dids/key/#usage","text":"See the Authentication page to learn how to use the Key DID method in your Ceramic project.","title":"Usage"},{"location":"authentication/dids/key/#design","text":"The DID document for a Key DID is statically generated from any Ed25519 cryptographic key pair. This Ed25519 key is used to control the DID. Key DID is lightweight, but the main drawback is that its DID document is immutable and has no ability to rotate keys if it is compromised; it is explicitly tied to a single crypto key. This makes Key DIDs best suited for users who will only want to ever use one keypair to control their DID, and who have strong key security practices - such as a developer.","title":"Design"},{"location":"authentication/dids/key/#other-did-methods","text":"Ceramic supports a few different DID methods for authentication. Below find links to the others: 3ID DID NFT DID (coming soon) Safe DID (coming soon)","title":"Other DID methods"},{"location":"authentication/legacy/3id-connect-migration/","text":"3ID Migration: 3Box to Ceramic \u00b6 If you have used 3Box with 3ID-Connect in the past, you will already have an existing 3ID. No additional steps have to be taken to migrate your existing 3ID to the Ceramic network. When you interact with any application on Ceramic through 3ID-Connect, your 3ID will automatically be migrated. The migration includes moving your 3ID and control of your 3ID to the Ceramic network, migrating your 3Box profile to the profile definition and schema in IDX, and lastly migrating your address, Twitter and Github links. Any additional data in 3Box may or may not be migrated by the applications themselves built on 3Box. Those applications will guide you through any additional migration steps if necessary. Migration Difficulties \u00b6 Most users will be able to migrate without difficulty, but there is a number of known instances where we can not easily migrate your 3ID. In theses cases we will create a new 3ID for you and partially migrate any data that we can. You will be able to re-add any profile data and social links that fail to migrate in the future. Very Early 3Box Users Early 3Box users will have muport DIDs instead of the now standard 3ID DID implementation. For future interoperability in Ceramic and to take advantage of all the features in 3ID we have chosen not to migrate these DIDs. When you use 3ID-Connect on Ceramic we will detect that you have a muport DID and instead create a new 3ID for you. We will still migrate your profile data if we can, but will not migrate your Twitter and Github links. Multiple Linked Accounts There was a known past bug in 3Box that resulted in multiple addresses being linked to a DID in an unexpected way. When you use 3ID-Connect on Ceramic we will detect that you have one of these accounts and instead create a new 3ID for you. Users accounts that have this issue may not have expected to link these accounts, so we will not migrate your profile data or your social links. Migration Failures 3Box existed for a while before Ceramic and we may have not built support for all prior existing formats. If migration fails at any point during the process, we will still attempt partial migrations when we can and continue with a best effort migration. If migration fails during 3ID migration, we will create a new 3ID and try to migrate your profile data still. If migration fails during profile or social link migration, we will return your migrated 3ID anyways. For Developers \u00b6 You can find more details in this blog post , if you are interested in the more technical details of the migration or in migrating your own application from 3Box to Ceramic. Questions or support? \u00b6 We're always available to answer any questions and help you through this migration. Reach out to us in the Ceramic Discord for assistance.","title":"3Box Migration"},{"location":"authentication/legacy/3id-connect-migration/#3id-migration-3box-to-ceramic","text":"If you have used 3Box with 3ID-Connect in the past, you will already have an existing 3ID. No additional steps have to be taken to migrate your existing 3ID to the Ceramic network. When you interact with any application on Ceramic through 3ID-Connect, your 3ID will automatically be migrated. The migration includes moving your 3ID and control of your 3ID to the Ceramic network, migrating your 3Box profile to the profile definition and schema in IDX, and lastly migrating your address, Twitter and Github links. Any additional data in 3Box may or may not be migrated by the applications themselves built on 3Box. Those applications will guide you through any additional migration steps if necessary.","title":"3ID Migration: 3Box to Ceramic"},{"location":"authentication/legacy/3id-connect-migration/#migration-difficulties","text":"Most users will be able to migrate without difficulty, but there is a number of known instances where we can not easily migrate your 3ID. In theses cases we will create a new 3ID for you and partially migrate any data that we can. You will be able to re-add any profile data and social links that fail to migrate in the future. Very Early 3Box Users Early 3Box users will have muport DIDs instead of the now standard 3ID DID implementation. For future interoperability in Ceramic and to take advantage of all the features in 3ID we have chosen not to migrate these DIDs. When you use 3ID-Connect on Ceramic we will detect that you have a muport DID and instead create a new 3ID for you. We will still migrate your profile data if we can, but will not migrate your Twitter and Github links. Multiple Linked Accounts There was a known past bug in 3Box that resulted in multiple addresses being linked to a DID in an unexpected way. When you use 3ID-Connect on Ceramic we will detect that you have one of these accounts and instead create a new 3ID for you. Users accounts that have this issue may not have expected to link these accounts, so we will not migrate your profile data or your social links. Migration Failures 3Box existed for a while before Ceramic and we may have not built support for all prior existing formats. If migration fails at any point during the process, we will still attempt partial migrations when we can and continue with a best effort migration. If migration fails during 3ID migration, we will create a new 3ID and try to migrate your profile data still. If migration fails during profile or social link migration, we will return your migrated 3ID anyways.","title":"Migration Difficulties"},{"location":"authentication/legacy/3id-connect-migration/#for-developers","text":"You can find more details in this blog post , if you are interested in the more technical details of the migration or in migrating your own application from 3Box to Ceramic.","title":"For Developers"},{"location":"authentication/legacy/3id-connect-migration/#questions-or-support","text":"We're always available to answer any questions and help you through this migration. Reach out to us in the Ceramic Discord for assistance.","title":"Questions or support?"},{"location":"authentication/wallets/3id-connect/","text":"3ID Connect \u00b6 3ID Connect is an authentication SDK for web applications that allows a user to control a 3ID DID using any number of blockchain accounts/wallets. 3ID Connect allows users to: - Create a 3ID - Control their 3ID with one or more blockchain wallets - Usage \u00b6 See the Authentication page to install 3ID Connect into your Ceramic web application. How it works \u00b6 Users without a 3ID linked to their wallet account \u00b6 User arrives at your application and signs in with their blockchain wallet User sees a 3ID Connect account creation prompt asking if they want to create a new 3ID for this account or link to an existing 3ID If user selects \"Create New 3ID\", they will be prompted in the wallet to sign two messages: one to add this account as an authentication method for their 3ID, and another to create a CAIP-10 Link which publicly associated their account with their 3ID. If the user selects \"Link to Existing 3ID\", they will be directed to a page where they can select a 3ID from a list of known 3IDs, then they will need to approve the two messages mentioned previously. Users with a 3ID linked to their wallet account \u00b6 User arrives at your application and signs in with their blockchain wallet User sees a 3ID Connect permissions prompt asking them to grant your application permissions Once approved, user is authenticated On future logins, users will not see the permissions prompt again unless they clear local storage for 3ID Connect. Design \u00b6 Under the hood 3ID Connect is built on a set of open standards: 3ID DID Method IDX 3ID Keychain CAIP-10 Links Supported blockchains \u00b6 Ethereum (and other EVM compatible chains) NEAR EOS Cosmos (coming soon) Polkadot (coming soon) Adding new blockchains \u00b6 Follow this tutorial to add support for new blockchains to 3ID Connect.","title":"3ID Connect"},{"location":"authentication/wallets/3id-connect/#3id-connect","text":"3ID Connect is an authentication SDK for web applications that allows a user to control a 3ID DID using any number of blockchain accounts/wallets. 3ID Connect allows users to: - Create a 3ID - Control their 3ID with one or more blockchain wallets -","title":"3ID Connect"},{"location":"authentication/wallets/3id-connect/#usage","text":"See the Authentication page to install 3ID Connect into your Ceramic web application.","title":"Usage"},{"location":"authentication/wallets/3id-connect/#how-it-works","text":"","title":"How it works"},{"location":"authentication/wallets/3id-connect/#users-without-a-3id-linked-to-their-wallet-account","text":"User arrives at your application and signs in with their blockchain wallet User sees a 3ID Connect account creation prompt asking if they want to create a new 3ID for this account or link to an existing 3ID If user selects \"Create New 3ID\", they will be prompted in the wallet to sign two messages: one to add this account as an authentication method for their 3ID, and another to create a CAIP-10 Link which publicly associated their account with their 3ID. If the user selects \"Link to Existing 3ID\", they will be directed to a page where they can select a 3ID from a list of known 3IDs, then they will need to approve the two messages mentioned previously.","title":"Users without a 3ID linked to their wallet account"},{"location":"authentication/wallets/3id-connect/#users-with-a-3id-linked-to-their-wallet-account","text":"User arrives at your application and signs in with their blockchain wallet User sees a 3ID Connect permissions prompt asking them to grant your application permissions Once approved, user is authenticated On future logins, users will not see the permissions prompt again unless they clear local storage for 3ID Connect.","title":"Users with a 3ID linked to their wallet account"},{"location":"authentication/wallets/3id-connect/#design","text":"Under the hood 3ID Connect is built on a set of open standards: 3ID DID Method IDX 3ID Keychain CAIP-10 Links","title":"Design"},{"location":"authentication/wallets/3id-connect/#supported-blockchains","text":"Ethereum (and other EVM compatible chains) NEAR EOS Cosmos (coming soon) Polkadot (coming soon)","title":"Supported blockchains"},{"location":"authentication/wallets/3id-connect/#adding-new-blockchains","text":"Follow this tutorial to add support for new blockchains to 3ID Connect.","title":"Adding new blockchains"},{"location":"build/authentication/","text":"Authentication \u00b6 This guide will help you add user authentication to your project. Authentication is needed when you want to perform writes . If you only want to perform queries , you do not need authentication. Prerequisites \u00b6 Authentication requires having installed a Ceramic client in your project and having configured a DID for that client with the proper DID Resolvers. Choose your setup \u00b6 DID method \u00b6 The first step in adding authentication to your project is choosing which DID method you want to support for user accounts. Due to their mutability and security, it is recommended that you use 3ID DID for users. DID Method Description Registration DID Documents Details 3ID DID A complete and flexible DID method built on Ceramic that supports key rotations and revocations Ceramic Mutable Learn Key DID A lightweight but inflexible DID method that does not support key rotations None Immutable Learn DID provider or wallet \u00b6 After deciding on a DID method, you need to install either a wallet or a provider for that method. The most commonly used DID providers and wallets can be found below. For most browser applications, it is recommended that you use 3ID Connect. Name DID Method Type Description Details 3ID Connect 3ID DID Wallet A hosted wallet and authentication system for browser apps using 3ID DIDs. Your application is not responsible for key management, and users can authenticate with their existing blockchain wallets. Learn 3id-did-provider 3ID DID Provider A JavaScript library for creating and interacting with 3ID DIDs. Your application is responsible for key management, and users need to authenticate with a DID seed or an auth secret. Learn key-did-provider-ed25519 Key DID Provider A JavaScript library for creating and interacting with Key DIDs. Your application is responsible for key managemet, and users need to authenticate with a DID seed. Learn Installation \u00b6 Install a DID wallet or provider in your project using npm. 3ID Connect $ npm install @3id/connect 3id-did-provider $ npm install 3id-did-provider key-did-provider $ npm install key-did-provider-ed25519 Create the Provider \u00b6 The authentication process varies depending on which wallet or provider you are using. Closely follow the steps below. 3ID Connect Import the provider \u00b6 import { ThreeIdConnect , < BlockchainAuthProvider > } from '@3id/connect' Example using an Ethereum wallet: import { ThreeIdConnect , EthereumAuthProvider } from '@3id/connect' Understanding BlockchainAuthProvider The BlockchainAuthProvider parameter is always required but the name shown here is just a placeholder. In your application, you should substitute in the specific BlockchainAuthProvider you are using. A full list of supported BlockchainAuthProviders can be found here . Request the user's blockchain address \u00b6 const addresses = await < blockchainName > . enable () Example using an Ethereum wallet: const addresses = await window . ethereum . enable () Request authentication from the user's blockchain wallet \u00b6 This will prompt the user with a 3ID Connect permissions window. const threeIdConnect = new ThreeIdConnect () const authProvider = new < BlockchainAuthProvider > ( < blockchainName > , addresses [ 0 ]) await threeIdConnect . connect ( authProvider ) Example using an Ethereum wallet: const authProvider = new EthereumAuthProvider ( window . ethereum , addresses [ 0 ]) await threeIdConnect . connect ( authProvider ) Create a provider instance \u00b6 const provider = await threeIdConnect . getDidProvider () 3id-did-provider Import the provider \u00b6 import ThreeIdProvider from '3id-did-provider' Get seed for DID \u00b6 Generate a random seed for a new user, or somehow get the existing seed for a returning user. Seeds should be a 32 byte Uint8Array. How to generate a seed Here's how to securely generate a seed in the proper format: import { randomBytes } from '@stablelib/random' const seed = randomBytes ( 32 ) Create a provider instance \u00b6 Option 1: Using the seed \u00b6 const threeId = await ThreeIdProvider . create ({ getPermission , seed }) const provider = threeId . getDidProvider () Option 2: Using an external auth method \u00b6 This option is useful if you want to enable multiple secrets (seeds) that are capable of controlling the 3ID DID. How to generate an authSecret Here's how to securely generate a seed in the proper format: import { randomBytes } from '@stablelib/random' const authSecret = randomBytes ( 32 ) const authId = 'myAuthenticationMethod' // a name of the auth method const threeId = await ThreeIdProvider . create ({ getPermission , authSecret , authId }) const provider = threeId . getDidProvider () Understanding getPermission The getPermission parameter is always required when creating an instance of ThreeIdProvider. It is used to give an application permission to decrypt and sign data. This function should present a dialog to the user in the wallet UI which asks for permission to access the given paths. The function is called with one parameter which is the request object. It looks like this: { type : 'authenticate' , origin : 'https://my.app.origin' , payload : { paths : [ '/path/1' , '/path/2' ] } } In the above example the app with origin https://my.app.origin is requesting access to /path/1 and /path/2. If the user approves, the function should return the paths array. If they decline, it will return an empty array. Note that a user may approve only some of the requested paths, which would return an array containing only the approved paths. The most simple getPermission function simply grants all requested permissions. const getPermission = async ( request ) => { return request . payload . paths } key-did-provider Import the provider \u00b6 Import the Key DID provider into your project. import { Ed25519Provider } from 'key-did-provider-ed25519' Get seed for DID \u00b6 Generate a random seed for a new user, or somehow get the existing seed for a returning user. Seeds should be a 32 byte Uint8Array. How to generate a seed Here's how to securely generate a seed in the proper format: import { randomBytes } from '@stablelib/random' const seed = randomBytes ( 32 ) Create a provider instance using the seed \u00b6 const provider = new Ed25519Provider ( seed ) Set the Provider \u00b6 Set the Provider instance to the DID instance used by your Ceramic client in order to perform writes. ceramic . did . setProvider ( provider ) Authenticate the DID \u00b6 Now all that's left is to authenticate to the Ceramic client's DID instance using the configured DID Provider. If you're using ThreeIdConnect, this step will cause a pop-up in your browser requesting permission to authenticate the DID. await ceramic . did . authenticate () Usage \u00b6 After authenticating, the user will now be able to perform writes on Ceramic using their DID.","title":"Authentication"},{"location":"build/authentication/#authentication","text":"This guide will help you add user authentication to your project. Authentication is needed when you want to perform writes . If you only want to perform queries , you do not need authentication.","title":"Authentication"},{"location":"build/authentication/#prerequisites","text":"Authentication requires having installed a Ceramic client in your project and having configured a DID for that client with the proper DID Resolvers.","title":"Prerequisites"},{"location":"build/authentication/#choose-your-setup","text":"","title":"Choose your setup"},{"location":"build/authentication/#did-method","text":"The first step in adding authentication to your project is choosing which DID method you want to support for user accounts. Due to their mutability and security, it is recommended that you use 3ID DID for users. DID Method Description Registration DID Documents Details 3ID DID A complete and flexible DID method built on Ceramic that supports key rotations and revocations Ceramic Mutable Learn Key DID A lightweight but inflexible DID method that does not support key rotations None Immutable Learn","title":"DID method"},{"location":"build/authentication/#did-provider-or-wallet","text":"After deciding on a DID method, you need to install either a wallet or a provider for that method. The most commonly used DID providers and wallets can be found below. For most browser applications, it is recommended that you use 3ID Connect. Name DID Method Type Description Details 3ID Connect 3ID DID Wallet A hosted wallet and authentication system for browser apps using 3ID DIDs. Your application is not responsible for key management, and users can authenticate with their existing blockchain wallets. Learn 3id-did-provider 3ID DID Provider A JavaScript library for creating and interacting with 3ID DIDs. Your application is responsible for key management, and users need to authenticate with a DID seed or an auth secret. Learn key-did-provider-ed25519 Key DID Provider A JavaScript library for creating and interacting with Key DIDs. Your application is responsible for key managemet, and users need to authenticate with a DID seed. Learn","title":"DID provider or wallet"},{"location":"build/authentication/#installation","text":"Install a DID wallet or provider in your project using npm. 3ID Connect $ npm install @3id/connect 3id-did-provider $ npm install 3id-did-provider key-did-provider $ npm install key-did-provider-ed25519","title":"Installation"},{"location":"build/authentication/#create-the-provider","text":"The authentication process varies depending on which wallet or provider you are using. Closely follow the steps below. 3ID Connect","title":"Create the Provider"},{"location":"build/authentication/#set-the-provider","text":"Set the Provider instance to the DID instance used by your Ceramic client in order to perform writes. ceramic . did . setProvider ( provider )","title":"Set the Provider"},{"location":"build/authentication/#authenticate-the-did","text":"Now all that's left is to authenticate to the Ceramic client's DID instance using the configured DID Provider. If you're using ThreeIdConnect, this step will cause a pop-up in your browser requesting permission to authenticate the DID. await ceramic . did . authenticate ()","title":"Authenticate the DID"},{"location":"build/authentication/#usage","text":"After authenticating, the user will now be able to perform writes on Ceramic using their DID.","title":"Usage"},{"location":"build/configure-did/","text":"Configure your DID \u00b6 This guide will help you set up a DID instance to your Ceramic client so it can function properly. Ceramic core clients always require a DID instance and the DID Resolver(s) contained within to verify proper ownership of Ceramic streams by validating signatures on Ceramic Commits when loading a stream. Ceramic http clients only require a DID instance if they will be used to perform writes to streams. Prerequisites \u00b6 Configuring your DID requires having installed a Ceramic client in your project. Create the DID Resolver \u00b6 The DID Resolver allows a Ceramic node to look up information about any DID it encounters within any Stream it loads or interacts with. It therefore must be capable of resolving more DID methods than just what is used by the authenticated user. It is recommended that all Ceramic nodes be able to resolve at least the did:3 and did:key DID methods. Import the resolvers \u00b6 Import Resolvers for all DID methods that this node will support import KeyDidResolver from 'key-did-resolver' import ThreeIdResolver from '@ceramicnetwork/3id-did-resolver' Construct a ResolverRegistry of all desired Resolvers \u00b6 const resolver = { ... KeyDidResolver . getResolver (), ... ThreeIdResolver . getResolver ( ceramic ) } Create the DID instance \u00b6 The DID instance wraps the DID Resolver (and optionally a DID Provider if you intend to authenticate your DID to allow writes). import { DID } from 'dids' const did = new DID ({ resolver }) Set the DID instance on the Ceramic client \u00b6 Set the DID instance to your Ceramic client so that it can use it to resolve DIDs to validate ownership of Ceramic Streams. ceramic . setDID ( did ) Authenticate the DID \u00b6 If you want to be able to perform writes with your Ceramic client, you will need to authenticate your DID first. To do that the DID must be provided a DID Provider instance. More information on how to do this is available on the authenication page. Usage \u00b6 After setting the DID instance on the Ceramic client, the application will now be able to perform reads on Ceramic. If the DID was authenticated , then the user will also be able to perform writes on Ceramic using their DID.","title":"Configure your DID"},{"location":"build/configure-did/#configure-your-did","text":"This guide will help you set up a DID instance to your Ceramic client so it can function properly. Ceramic core clients always require a DID instance and the DID Resolver(s) contained within to verify proper ownership of Ceramic streams by validating signatures on Ceramic Commits when loading a stream. Ceramic http clients only require a DID instance if they will be used to perform writes to streams.","title":"Configure your DID"},{"location":"build/configure-did/#prerequisites","text":"Configuring your DID requires having installed a Ceramic client in your project.","title":"Prerequisites"},{"location":"build/configure-did/#create-the-did-resolver","text":"The DID Resolver allows a Ceramic node to look up information about any DID it encounters within any Stream it loads or interacts with. It therefore must be capable of resolving more DID methods than just what is used by the authenticated user. It is recommended that all Ceramic nodes be able to resolve at least the did:3 and did:key DID methods.","title":"Create the DID Resolver"},{"location":"build/configure-did/#create-the-did-instance","text":"The DID instance wraps the DID Resolver (and optionally a DID Provider if you intend to authenticate your DID to allow writes). import { DID } from 'dids' const did = new DID ({ resolver })","title":"Create the DID instance"},{"location":"build/configure-did/#set-the-did-instance-on-the-ceramic-client","text":"Set the DID instance to your Ceramic client so that it can use it to resolve DIDs to validate ownership of Ceramic Streams. ceramic . setDID ( did )","title":"Set the DID instance on the Ceramic client"},{"location":"build/configure-did/#authenticate-the-did","text":"If you want to be able to perform writes with your Ceramic client, you will need to authenticate your DID first. To do that the DID must be provided a DID Provider instance. More information on how to do this is available on the authenication page.","title":"Authenticate the DID"},{"location":"build/configure-did/#usage","text":"After setting the DID instance on the Ceramic client, the application will now be able to perform reads on Ceramic. If the DID was authenticated , then the user will also be able to perform writes on Ceramic using their DID.","title":"Usage"},{"location":"build/installation/","text":"Installation \u00b6 Install a Ceramic client to perform writes and queries on the network. Project status: Clay testnet is now live. Clay is a decentralized public network ready for experimental application development and testing, but you still may encounter a few issues. It is the last major milestone before Fire mainnet, which is under development and will launch in late Q1 2021. Documents published on Clay will not be portable to Fire. Please reach out on Discord or create an issue on Github to report any issues. Read the full announcement here . Clients \u00b6 Ceramic is available in a variety of clients suited for different use cases. For optimal performance, it is recommended that you use the HTTP Client when building an application. Client Description Usage Details HTTP An API for interacting with a remote Ceramic daemon over HTTP Runtime Learn Core An API for running the entire Ceramic protocol in a JavaScript environment Runtime Learn CLI A command line interface for interacting with a Ceramic node, also used to spin up a Ceramic daemon Development, Infrastructure Learn Prerequisites \u00b6 This installation guide will use a terminal, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may be able to get it to work anyway, however you will need to have the node-pre-gyp package installed globally: npm install -g node-pre-gyp This is required until node-webrtc (which IPFS depends on) is upgraded . Installation \u00b6 Open your terminal and install a client using npm. HTTP $ npm install @ceramicnetwork/http-client Core $ npm install @ceramicnetwork/core CLI $ npm install -g @ceramicnetwork/cli The CLI requires Node.js. Make sure to have an up-to-date version installed on your machine. Setup \u00b6 Setup your client within your project. HTTP Import the HTTP client \u00b6 import CeramicClient from '@ceramicnetwork/http-client' Connect to a node \u00b6 const API_URL = \"http://yourceramicnode.com\" Node options When using the HTTP API, you need to connect to a remote Ceramic node by passing its URL. Here are your options for nodes that run on the Clay testnet. Choose the option that best suits your use case: Community gateway https://gateway-clay.ceramic.network : Provides read-only access to the Clay testnet. (recommended) Community dev node https://ceramic-clay.3boxlabs.com : Provides write and read access to the Clay testnet. This node is occasionally wiped and does not guarantee document persistence. (recommended) Run your own node https://yourEndpoint.com : Provides write and read access to the Clay testnet. Running your own node allows you to persist documents and have full control, however this is process is not yet well documented. If you choose to run your own node, be sure to add your node to the peerlist by submitting a pull request. This allows other nodes to discover your node. LocalHost https://localhost:7007 : Provides read access to the Clay testnet. Writes made to this local node will only be available to nodes in the peerlist , but will not be available to other nodes on the network. Users need to first have a Ceramic daemon running locally using the CLI. Create an instance \u00b6 const ceramic = new CeramicClient ( API_URL ) Authenticate your client to perform writes \u00b6 Ceramic clients need access to a DID instance to create and validate cryptographic signatures on Ceramic commits. If you only intend to load streams you can skip this step. If you want to be able to create and update streams, however, you'll need to Configure a DID and then Authenticate it. Core Import the Core client \u00b6 import Ceramic from '@ceramicnetwork/core' Import IPFS with dag-jose \u00b6 Ceramic utilizes the dag-jose IPLD codec to store signed and encrypted data in IPFS. In order to create an instance of Ceramic core, you first need to create an instance of js-ipfs with dag-jose enabled. import IPFS from 'ipfs' import dagJose from 'dag-jose' import { sha256 } from 'multiformats/hashes/sha2' import legacy from 'multiformats/legacy' const hasher = {} hasher [ sha256 . code ] = sha256 const dagJoseFormat = legacy ( dagJose , { hashes : hasher }) Create an IPFS instance \u00b6 const ipfs = await Ipfs . create ({ ipld : { formats : [ dagJoseFormat ] } }) Create a Ceramic instance \u00b6 Create an instance of Ceramic by passing ipfs and an optional configuration object. const ceramic = await Ceramic . create ( ipfs , config ) Provide a DID instance to the Ceramic client. \u00b6 Ceramic instances need access to a DID instance to use to resolve DIDs and to create and validate cryptographic signatures on Ceramic commits. See the Configure your DID page for more information on how to do this. Authenticate your client to perform writes \u00b6 Ceramic instances need a DID Provider to create cryptographic signatures on Ceramic commits. If you only intend to load streams you can skip this step. If you want to be able to create and update streams, however, you'll need to authenticate your client. See the Authentication page for more information on how to do this. CLI Start the Ceramic daemon \u00b6 This commands starts a local Ceramic node. $ ceramic daemon Connect to a remote Ceramic node \u00b6 By default the Ceramic CLI communicates with the local node that you started with the ceramic daemon command. However, it is possible to use the CLI to communicate with a remote node. To do this, use the config set command to set the ceramicHost variable to the URL of the node you wish to use. $ ceramic config set ceramicHost 'https://yourceramicnode.com' Node options When using the CLI, you need to connect to a remote Ceramic node by passing its URL. Here are your options for nodes that run on the Clay testnet. Choose the option that best suits your use case: LocalHost https://localhost:7007 : Enabled by default in the CLI. Provides read access to the Clay testnet. Writes made to this local node will only be available to nodes in the peerlist , but will not be available to other nodes on the network. Community gateway https://gateway-clay.ceramic.network : Provides read-only access to the Clay testnet. Community dev node https://ceramic-clay.3boxlabs.com : Provides write and read access to the Clay testnet. This node is occasionally wiped and does not guarantee document persistence. (recommended) Run your own node https://yourEndpoint.com : Provides write and read access to the Clay testnet. Running your own node allows you to persist documents and have full control, however this is process is not yet well documented. If you choose to run your own node, be sure to add your node to the peerlist by submitting a pull request. This allows other nodes to discover your node.","title":"Installation"},{"location":"build/installation/#installation","text":"Install a Ceramic client to perform writes and queries on the network. Project status: Clay testnet is now live. Clay is a decentralized public network ready for experimental application development and testing, but you still may encounter a few issues. It is the last major milestone before Fire mainnet, which is under development and will launch in late Q1 2021. Documents published on Clay will not be portable to Fire. Please reach out on Discord or create an issue on Github to report any issues. Read the full announcement here .","title":"Installation"},{"location":"build/installation/#clients","text":"Ceramic is available in a variety of clients suited for different use cases. For optimal performance, it is recommended that you use the HTTP Client when building an application. Client Description Usage Details HTTP An API for interacting with a remote Ceramic daemon over HTTP Runtime Learn Core An API for running the entire Ceramic protocol in a JavaScript environment Runtime Learn CLI A command line interface for interacting with a Ceramic node, also used to spin up a Ceramic daemon Development, Infrastructure Learn","title":"Clients"},{"location":"build/installation/#prerequisites","text":"This installation guide will use a terminal, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may be able to get it to work anyway, however you will need to have the node-pre-gyp package installed globally: npm install -g node-pre-gyp This is required until node-webrtc (which IPFS depends on) is upgraded .","title":"Prerequisites"},{"location":"build/installation/#installation_1","text":"Open your terminal and install a client using npm. HTTP $ npm install @ceramicnetwork/http-client Core $ npm install @ceramicnetwork/core CLI $ npm install -g @ceramicnetwork/cli The CLI requires Node.js. Make sure to have an up-to-date version installed on your machine.","title":"Installation"},{"location":"build/installation/#setup","text":"Setup your client within your project. HTTP","title":"Setup"},{"location":"build/nodes/","text":"Node configuration \u00b6 There are multiple ways to setup, run, and use Ceramic nodes and the optimal setup for you will differ based on you and your users needs. Core \u00b6 Ceramic core contains the full implementation of the Ceramic protocol and can be used directly through the JavaScript CeramicApi . The core implementation can be used in any JavaScript environment, such as your tests, in-browser, or nodejs. When running Ceramic core all streams that are created, loaded, or pinned get verified in the local environment, which is great if you need maximal decentralization and resilience in your application. However, this great power comes with responsibility. In order to run Ceramic Core you need to configure your own IPFS node which supports dag-jose and ensure connectivity to the rest of the Ceramic network. Further, a stream created on an instance of Ceramic core will only be available on the network as long as this node remains online. So if your setup for example uses in-browser nodes and your user closes the tab, any stream created by that user will remain unavailable until the user opens the application again. One way to mitigate this is to pin streams on separate long running nodes. CLI \u00b6 The Ceramic command line interface provides a way to spawn a Ceramic daemon and to interact with this (or remote) daemon though simple commands. Ceramic daemon \u00b6 The simplest way to run a Ceramic node is to run the ceramic daemon command in your console. This command starts a Ceramic node with a standard cofiguration in a few steps. First a properly configured IPFS instance is started, IPFS is then used to create an instance of Ceramic core. Once Ceramic core is running an HTTP server is started that serves the Ceramic HTTP API . The node is now ready to accept requests from the local environment or remotely. By default the daemon runs a bundled IPFS instance. It's also possible to run a separate service for IPFS using the @ceramicnetwork/ipfs-daemon npm package. Regardless of how the IPFS instance is managed, if you want your node to be discoverable from the network, make sure the appropriate ports used by IPFS and the Ceramic HTTP API are publicly accessible (for example if you are behind a router you may need to set up port forwarding). Also be sure to add your node to the peerlist by submitting a pull request (this is a temporary measure to enhance peer discovery since js-ipfs doesn't support DHT lookups yet). HTTP Client \u00b6 The Ceramic HTTP client is a lighter way of interacting with the Ceramic network. It connects to a remote Ceramic http endpoint to read and write data. This means that state validation happens in the remote node which the client trusts. Important to note however is the user's keys always live client side and all updates are authored on the client and then sent to the remote http endpoint to write the update to the network. The HTTP client also implements the CeramicApi so it can be used interchangeably with Core. Hosted nodes \u00b6 The main consideration when using the Ceramic HTTP client is which remote Ceramic node to use. Options include running your own node, or using a node managed by some service provider. Hosting your own node \u00b6 To get started running your own node you can basically just run the ceramic daemon command. This will get you started with a simple node setup. When running a node in production there are a variety of factors to consider, but we won't go into details here. After starting your node it should be available on http://localhost:7007 . Using the gateway \u00b6 If you only want to read data from the network you can use the community gateway. This is a node hosted by 3Box Labs which have stream writes disabled. https://gateway.ceramic.network - the gateway for Ceramic mainnet https://gateway-clay.ceramic.network - the gateway for the Clay testnet 3Box Labs test node \u00b6 3Box Labs provides a node that can be used to get started developing on the Clay testnet. This node will run the latest release candidate of the Ceramic protocol. The node will be periodically wiped, so don't rely on it for production data (you shouldn't anyway since it's a testnet). https://ceramic-clay.3boxlabs.com Third party service providers \u00b6 Contact 3Box Labs if you want to be listed here!","title":"Node configuration"},{"location":"build/nodes/#node-configuration","text":"There are multiple ways to setup, run, and use Ceramic nodes and the optimal setup for you will differ based on you and your users needs.","title":"Node configuration"},{"location":"build/nodes/#core","text":"Ceramic core contains the full implementation of the Ceramic protocol and can be used directly through the JavaScript CeramicApi . The core implementation can be used in any JavaScript environment, such as your tests, in-browser, or nodejs. When running Ceramic core all streams that are created, loaded, or pinned get verified in the local environment, which is great if you need maximal decentralization and resilience in your application. However, this great power comes with responsibility. In order to run Ceramic Core you need to configure your own IPFS node which supports dag-jose and ensure connectivity to the rest of the Ceramic network. Further, a stream created on an instance of Ceramic core will only be available on the network as long as this node remains online. So if your setup for example uses in-browser nodes and your user closes the tab, any stream created by that user will remain unavailable until the user opens the application again. One way to mitigate this is to pin streams on separate long running nodes.","title":"Core"},{"location":"build/nodes/#cli","text":"The Ceramic command line interface provides a way to spawn a Ceramic daemon and to interact with this (or remote) daemon though simple commands.","title":"CLI"},{"location":"build/nodes/#ceramic-daemon","text":"The simplest way to run a Ceramic node is to run the ceramic daemon command in your console. This command starts a Ceramic node with a standard cofiguration in a few steps. First a properly configured IPFS instance is started, IPFS is then used to create an instance of Ceramic core. Once Ceramic core is running an HTTP server is started that serves the Ceramic HTTP API . The node is now ready to accept requests from the local environment or remotely. By default the daemon runs a bundled IPFS instance. It's also possible to run a separate service for IPFS using the @ceramicnetwork/ipfs-daemon npm package. Regardless of how the IPFS instance is managed, if you want your node to be discoverable from the network, make sure the appropriate ports used by IPFS and the Ceramic HTTP API are publicly accessible (for example if you are behind a router you may need to set up port forwarding). Also be sure to add your node to the peerlist by submitting a pull request (this is a temporary measure to enhance peer discovery since js-ipfs doesn't support DHT lookups yet).","title":"Ceramic daemon"},{"location":"build/nodes/#http-client","text":"The Ceramic HTTP client is a lighter way of interacting with the Ceramic network. It connects to a remote Ceramic http endpoint to read and write data. This means that state validation happens in the remote node which the client trusts. Important to note however is the user's keys always live client side and all updates are authored on the client and then sent to the remote http endpoint to write the update to the network. The HTTP client also implements the CeramicApi so it can be used interchangeably with Core.","title":"HTTP Client"},{"location":"build/nodes/#hosted-nodes","text":"The main consideration when using the Ceramic HTTP client is which remote Ceramic node to use. Options include running your own node, or using a node managed by some service provider.","title":"Hosted nodes"},{"location":"build/nodes/#hosting-your-own-node","text":"To get started running your own node you can basically just run the ceramic daemon command. This will get you started with a simple node setup. When running a node in production there are a variety of factors to consider, but we won't go into details here. After starting your node it should be available on http://localhost:7007 .","title":"Hosting your own node"},{"location":"build/nodes/#using-the-gateway","text":"If you only want to read data from the network you can use the community gateway. This is a node hosted by 3Box Labs which have stream writes disabled. https://gateway.ceramic.network - the gateway for Ceramic mainnet https://gateway-clay.ceramic.network - the gateway for the Clay testnet","title":"Using the gateway"},{"location":"build/nodes/#3box-labs-test-node","text":"3Box Labs provides a node that can be used to get started developing on the Clay testnet. This node will run the latest release candidate of the Ceramic protocol. The node will be periodically wiped, so don't rely on it for production data (you shouldn't anyway since it's a testnet). https://ceramic-clay.3boxlabs.com","title":"3Box Labs test node"},{"location":"build/nodes/#third-party-service-providers","text":"Contact 3Box Labs if you want to be listed here!","title":"Third party service providers"},{"location":"build/pinning/","text":"Pinning \u00b6 Pinning allows you to add and remove streams from the permanent pinset in your Ceramic node. By default Ceramic will garbage collect any stream that has been created, modified, or loaded after some period of time. In order to prevent the loss of streams due to garbage collection, you need to pin the streams that you wish to persist. Pinning instructs the Ceramic node to keep them around in persistent storage until they are unpinned. Prerequisites \u00b6 Pinning requires having installed a Ceramic client in your project. Add to pinset \u00b6 Use the pin.add() method to add a stream to your permanent pinset. const streamId = 'kjzl6cwe1jw14...' await ceramic . pin . add ( streamId ) API reference Remove from pinset \u00b6 Use the pin.rm() method to remove a stream from your permanent pinset. const streamId = 'kjzl6cwe1jw14...' await ceramic . pin . rm ( streamId ) API reference List streamss in pinset \u00b6 Use the pin.ls() method to list streams currently in your permanent pinset. const streamIds = await ceramic . pin . ls () API reference","title":"Pinning"},{"location":"build/pinning/#pinning","text":"Pinning allows you to add and remove streams from the permanent pinset in your Ceramic node. By default Ceramic will garbage collect any stream that has been created, modified, or loaded after some period of time. In order to prevent the loss of streams due to garbage collection, you need to pin the streams that you wish to persist. Pinning instructs the Ceramic node to keep them around in persistent storage until they are unpinned.","title":"Pinning"},{"location":"build/pinning/#prerequisites","text":"Pinning requires having installed a Ceramic client in your project.","title":"Prerequisites"},{"location":"build/pinning/#add-to-pinset","text":"Use the pin.add() method to add a stream to your permanent pinset. const streamId = 'kjzl6cwe1jw14...' await ceramic . pin . add ( streamId ) API reference","title":"Add to pinset"},{"location":"build/pinning/#remove-from-pinset","text":"Use the pin.rm() method to remove a stream from your permanent pinset. const streamId = 'kjzl6cwe1jw14...' await ceramic . pin . rm ( streamId ) API reference","title":"Remove from pinset"},{"location":"build/pinning/#list-streamss-in-pinset","text":"Use the pin.ls() method to list streams currently in your permanent pinset. const streamIds = await ceramic . pin . ls () API reference","title":"List streamss in pinset"},{"location":"build/queries/","text":"Queries \u00b6 This guide demonstrates how to query documents on the Ceramic network during runtime using the HTTP and core clients. You can also use the CLI to query documents as shown in the Quick Start guide. Prerequisites \u00b6 You need to have an installed client to perform queries during runtime. Query a stream \u00b6 Use the loadStream() method to load a single stream using its StreamID . const streamId = 'kjzl6cwe1jw14...' const stream = await ceramic . loadStream ( streamId ) Loading the proper stream type When using the Typescript APIs, loadStream by default returns an object of type Stream , which will not have any methods available to perform updates, or any other streamtype-specific methods or accessors. To be able to perform updates, as well as to access streamtype-specific data or functionality, you need to specialize the loadStream method on the StreamType of the Stream being loaded. For example, to load a TileDocument , you would say await ceramic.loadStream<TileDocument>(streamId) API reference Load a stream at a specific commit \u00b6 If you want to see the contents of a stream as of a specific point in time, it's possible to pass a CommitID instead of a StreamID to the loadStream() method. This will cause the Stream to be loaded at the specified commit, rather than the current commit as loaded from the network. When loading with a CommitID the returned Stream object will be marked as readonly and cannot be used to perform updates. If you wish to perform updates, load a new instance of the Stream using its StreamID. Query multiple streams \u00b6 Use the multiQuery() method to load multiple streams at once. The returned object is a map from StreamIDs to stream instances. const queries = [{ streamId : 'kjzl6cwe1jw...14' }, { streamId : 'kjzl6cwe1jw...15' }] const streamMap = await ceramic . multiQuery ( queries ) API reference Query document paths \u00b6 Use the multiQuery() method to load one or more streams using known paths from a root stream to its linked streams. Imagine a stream kjzl6cwe1jw...14 whose content contains the StreamIDs of two other streams. These StreamIDs exist at various levels within a nested JSON structure. { a : 'kjzl6cwe1jw...15' , b : { c : 'kjzl6cwe1jw...16' } } In the stream above, the path from root stream kjzl6cwe1jw...14 to linked stream kjzl6cwe1jw...15 is /a and the path to linked stream kjzl6cwe1jw...16 is /b/c . Using the StreamID of the root stream and the paths outlined here, we use multiQuery() to query all three streams at once without needing to explicitly know the StreamIDs of the two linked streams. The multiQuery() below will return a map with all three streams. const queries = [{ streamId : 'kjzl6cwe1jw...14' paths : [ '/a' , '/b/c' ] }] const streamMap = await ceramic . multiQuery ( queries ) API reference Stream information \u00b6 To get specific information about the stream that you created or loaded you can use the accessors on the Stream class. Below are some examples. API reference StreamID \u00b6 Use the stream.id property to get the unique StreamID for this stream. const streamId = stream . id API reference Latest CommitID \u00b6 Use the stream.commitId property to get latest CommitID of a stream. const commitId = stream . commitId API reference Anchor CommitIDs \u00b6 Use the stream.anchorCommitIds property to get all CommitIDs which are anchor commits for this stream. const anchorCommits = stream . anchorCommitIds API reference","title":"Queries"},{"location":"build/queries/#queries","text":"This guide demonstrates how to query documents on the Ceramic network during runtime using the HTTP and core clients. You can also use the CLI to query documents as shown in the Quick Start guide.","title":"Queries"},{"location":"build/queries/#prerequisites","text":"You need to have an installed client to perform queries during runtime.","title":"Prerequisites"},{"location":"build/queries/#query-a-stream","text":"Use the loadStream() method to load a single stream using its StreamID . const streamId = 'kjzl6cwe1jw14...' const stream = await ceramic . loadStream ( streamId ) Loading the proper stream type When using the Typescript APIs, loadStream by default returns an object of type Stream , which will not have any methods available to perform updates, or any other streamtype-specific methods or accessors. To be able to perform updates, as well as to access streamtype-specific data or functionality, you need to specialize the loadStream method on the StreamType of the Stream being loaded. For example, to load a TileDocument , you would say await ceramic.loadStream<TileDocument>(streamId) API reference","title":"Query a stream"},{"location":"build/queries/#load-a-stream-at-a-specific-commit","text":"If you want to see the contents of a stream as of a specific point in time, it's possible to pass a CommitID instead of a StreamID to the loadStream() method. This will cause the Stream to be loaded at the specified commit, rather than the current commit as loaded from the network. When loading with a CommitID the returned Stream object will be marked as readonly and cannot be used to perform updates. If you wish to perform updates, load a new instance of the Stream using its StreamID.","title":"Load a stream at a specific commit"},{"location":"build/queries/#query-multiple-streams","text":"Use the multiQuery() method to load multiple streams at once. The returned object is a map from StreamIDs to stream instances. const queries = [{ streamId : 'kjzl6cwe1jw...14' }, { streamId : 'kjzl6cwe1jw...15' }] const streamMap = await ceramic . multiQuery ( queries ) API reference","title":"Query multiple streams"},{"location":"build/queries/#query-document-paths","text":"Use the multiQuery() method to load one or more streams using known paths from a root stream to its linked streams. Imagine a stream kjzl6cwe1jw...14 whose content contains the StreamIDs of two other streams. These StreamIDs exist at various levels within a nested JSON structure. { a : 'kjzl6cwe1jw...15' , b : { c : 'kjzl6cwe1jw...16' } } In the stream above, the path from root stream kjzl6cwe1jw...14 to linked stream kjzl6cwe1jw...15 is /a and the path to linked stream kjzl6cwe1jw...16 is /b/c . Using the StreamID of the root stream and the paths outlined here, we use multiQuery() to query all three streams at once without needing to explicitly know the StreamIDs of the two linked streams. The multiQuery() below will return a map with all three streams. const queries = [{ streamId : 'kjzl6cwe1jw...14' paths : [ '/a' , '/b/c' ] }] const streamMap = await ceramic . multiQuery ( queries ) API reference","title":"Query document paths"},{"location":"build/queries/#stream-information","text":"To get specific information about the stream that you created or loaded you can use the accessors on the Stream class. Below are some examples. API reference","title":"Stream information"},{"location":"build/queries/#streamid","text":"Use the stream.id property to get the unique StreamID for this stream. const streamId = stream . id API reference","title":"StreamID"},{"location":"build/queries/#latest-commitid","text":"Use the stream.commitId property to get latest CommitID of a stream. const commitId = stream . commitId API reference","title":"Latest CommitID"},{"location":"build/queries/#anchor-commitids","text":"Use the stream.anchorCommitIds property to get all CommitIDs which are anchor commits for this stream. const anchorCommits = stream . anchorCommitIds API reference","title":"Anchor CommitIDs"},{"location":"build/quick-start/","text":"Project status: Clay testnet is now live. Clay is a decentralized public network ready for experimental application development and testing, but you still may encounter a few issues. It is the last major milestone before Fire mainnet, which is under development and will launch in late Q1 2021. Documents published on Clay will not be portable to Fire. Please reach out on Discord or create an issue on Github to report any issues. Read the full announcement here . Quick start \u00b6 Learn the basics by setting up and interacting with the Ceramic CLI. This tutorial serves as a simple introduction to Ceramic concepts. See installation to install Ceramic in your project and start building applications. Want an even faster way to try Ceramic? Visit the Playground demo app to test the full stack of Ceramic components in the browser without needing to install anything. Prerequisites \u00b6 This quick start guide will use a terminal, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may be able to get it to work anyway, however you will need to have the node-pre-gyp package installed globally: npm install -g node-pre-gyp This is required until node-webrtc (which IPFS depends on) is upgraded . Install the CLI \u00b6 Install the Ceramic CLI using your terminal. npm install -g @ceramicnetwork/cli Start the daemon \u00b6 Start a Ceramic daemon on your local machine and automatically connect to it on port 7007, http://localhost:7007 . ceramic daemon Node configurations There are multiple options you can configure when you start the ceramic daemon. Network : By default the CLI starts a Ceramic node on the clay testnet. If you would like to use a different Ceramic network, you can specify this with the --network option. Additional configurations : Use the ceramic daemon -h command to see additional options. Authentication \u00b6 By default, the Ceramic CLI is authenticated with a Key DID . The seed for this DID is stored in ~/.ceramic/config.json . If this file is not present on startup a new DID will be randomly generated. It's currently not possible to use the Ceramic CLI with other DID methods. Create a stream \u00b6 Use the create command to create a new stream. In the example below we create a stream of type TileDocument . Note that TileDocument is the only stream type that can currently be created by the Ceramic CLI. Command $ ceramic create tile --content '{ \"Foo\": \"Bar\" }' Output StreamID ( kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa ) { \"Foo\" : \"Bar\" } The first line of the output is the StreamID , which is the persistent identifier of our newly created stream. This StreamID will be different for you, since you created it with your DID. Below the StreamID is the current content of the stream. More options --controllers : set the controller of the stream --schema : set the schema of the TileDocument Run ceramic create -h to see all available options Query a stream \u00b6 Use the show command to query the current state of a stream. You will need to provide its StreamID . Command $ ceramic show kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa You should use your StreamID instead of the StreamID included here. Output { \"Foo\" : \"Bar\" } Use the state command to query the entire state of a stream. Command $ ceramic state kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa You should use your StreamID instead of the StreamID included here. Output before anchor { \"type\" : 0 , \"content\" : { \"Foo\" : \"Bar\" } , \"metadata\" : { \"unique\" : \"E4qPslUd0qo98TZX\" , \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/24/2021, 11:45:00 AM\" } Here we can see various information about the stream such as content , controllers , and schema . In your output you should see your local DID as the controller, instead of the DID we show here. You will also see a different randomly-generated \"unique\" string for any TileDocument that was created without the --deterministic flag. We can also see the current anchorStatus of our stream, and that it has been scheduled to be anchored at 11:45 on the 24 th of January 2021. Once this anchor is finalized, the state of the stream will automatically be updated with a new entry in the log and anchorStatus will be set to ANCHORED . Output after anchor { \"type\" : 0 , \"content\" : { \"Foo\" : \"Bar\" } , \"metadata\" : { \"unique\" : \"E4qPslUd0qo98TZX\" , \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"ANCHORED\" , \"log\" : [ { \"cid\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"type\" : 0 } , { \"cid\" : \"bafyreig6hostufw42cmz2cnn7hpvb6pau67a2n2syhzej7orqxfymdayyq\" , \"type\" : 2 } ] , \"anchorScheduledFor\" : null, \"anchorProof\" : { \"root\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"txHash\" : \"bagjqcgza4xgkpjodtqtgyu2fx6rdr6fb6mhevd5hy4253tl6pjlssidpwaha\" , \"chainId\" : \"eip155:3\" , \"blockNumber\" : 9527752 , \"blockTimestamp\" : 1611485094 } } This output was seen after the anchor has been created. The stream state has now shifted anchorStatus to ANCHORED . You can also see that the log contains one more entry. Update a stream \u00b6 Use the update command to update a stream. Your DID must be the controller of the stream in order to update it. Note that TileDocument is the only stream type that can currently be updated by the CLI. Command $ ceramic update kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa --content '{ \"Foo\": \"Baz\" }' You should use your StreamID instead of the StreamID included here. Output { \"Foo\" : \"Baz\" } More options Currently you can change content , controllers , and schema using the CLI. Run ceramic update -h for more information. Create a schema \u00b6 Ceramic TileDocuments can enforce that their contents adhere to a specified schema. The schemas themselves are Ceramic TileDocuments where the content is a json-schema . For example we can create a schema that requires a document to have a title and message . Command $ ceramic create tile --content ' { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Reward\", \"type\": \"object\", \"properties\": { \"title\": { \"type\": \"string\" }, \"message\": { \"type\": \"string\" } }, \"required\": [ \"message\", \"title\" ] }' Output StreamID ( kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb ) { \"type\" : \"object\" , \"title\" : \"Reward\" , \" $schema \" : \"http://json-schema.org/draft-07/schema#\" , \"required\" : [ \"message\" , \"title\" ] , \"properties\" : { \"title\" : { \"type\" : \"string\" } , \"message\" : { \"type\" : \"string\" } } } Create a TileDocument that uses a schema \u00b6 First, use the commits command to list the commitIDs contained in the schema document. When creating a TileDocument that uses this schema, we need to use a commitID instead of the DocID to enforce that we are using a specific version of the schema since the schema document is mutable and can be updated. Command $ ceramic commits kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb You should use your StreamID for the stream containing the json-schema you want to enforce, instead of the StreamID included here. Output [ \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" ] If a stream contains multiple commits and you're not sure which one you want, use the show command to show the content of the stream at the given commit. Once you retrieve the desired commit, you can now create a TileDocument that is enforced to conform to this version of the schema. Use the create command and pass the --schema option along with your commitID. Command $ ceramic create tile --content '{ \"title\": \"My first document with schema\", \"message\": \"Hello World\" }' --schema k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8 You should use your commitID instead of the commitID included here. Output StreamID ( kjzl6cwe1jw149tvfh6otqfzd2hfknkifb1z2lakozkicvau0xldzzdzwfbsztj ) { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" } Query the document you created \u00b6 Use the state command to query the state of the TileDocument we just created. We can see that the schema is set to the correct commitID. Command $ ceramic state kjzl6cwe1jw14b5sr79heovz7fziz4dxcn8upx3bcesriloqcui137k6rq6g2mn You should use your StreamID instead of the StreamID included here. Output { \"type\" : 0 , \"content\" : { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" } , \"metadata\" : { \"unique\" : \"GR5tBtHdaw608esV\" , \"schema\" : \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" , \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera5qxg5zabjjvwpcbia6c3t6vebgo4brgmsagxezdjgk4vxnzwb5hq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/13/2021, 1:45:00 PM\" } That's it! \u00b6 Congratulations on completing this tutorial! You're well on your way to becoming a Ceramic developer. Now let's install Ceramic in your project \u2192","title":"Quick Start"},{"location":"build/quick-start/#quick-start","text":"Learn the basics by setting up and interacting with the Ceramic CLI. This tutorial serves as a simple introduction to Ceramic concepts. See installation to install Ceramic in your project and start building applications. Want an even faster way to try Ceramic? Visit the Playground demo app to test the full stack of Ceramic components in the browser without needing to install anything.","title":"Quick start"},{"location":"build/quick-start/#prerequisites","text":"This quick start guide will use a terminal, Node.js v14, and npm v6. Make sure to have these installed on your machine. While npm v7 is not officially supported, you may be able to get it to work anyway, however you will need to have the node-pre-gyp package installed globally: npm install -g node-pre-gyp This is required until node-webrtc (which IPFS depends on) is upgraded .","title":"Prerequisites"},{"location":"build/quick-start/#install-the-cli","text":"Install the Ceramic CLI using your terminal. npm install -g @ceramicnetwork/cli","title":"Install the CLI"},{"location":"build/quick-start/#start-the-daemon","text":"Start a Ceramic daemon on your local machine and automatically connect to it on port 7007, http://localhost:7007 . ceramic daemon Node configurations There are multiple options you can configure when you start the ceramic daemon. Network : By default the CLI starts a Ceramic node on the clay testnet. If you would like to use a different Ceramic network, you can specify this with the --network option. Additional configurations : Use the ceramic daemon -h command to see additional options.","title":"Start the daemon"},{"location":"build/quick-start/#authentication","text":"By default, the Ceramic CLI is authenticated with a Key DID . The seed for this DID is stored in ~/.ceramic/config.json . If this file is not present on startup a new DID will be randomly generated. It's currently not possible to use the Ceramic CLI with other DID methods.","title":"Authentication"},{"location":"build/quick-start/#create-a-stream","text":"Use the create command to create a new stream. In the example below we create a stream of type TileDocument . Note that TileDocument is the only stream type that can currently be created by the Ceramic CLI. Command $ ceramic create tile --content '{ \"Foo\": \"Bar\" }' Output StreamID ( kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa ) { \"Foo\" : \"Bar\" } The first line of the output is the StreamID , which is the persistent identifier of our newly created stream. This StreamID will be different for you, since you created it with your DID. Below the StreamID is the current content of the stream. More options --controllers : set the controller of the stream --schema : set the schema of the TileDocument Run ceramic create -h to see all available options","title":"Create a stream"},{"location":"build/quick-start/#query-a-stream","text":"Use the show command to query the current state of a stream. You will need to provide its StreamID . Command $ ceramic show kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa You should use your StreamID instead of the StreamID included here. Output { \"Foo\" : \"Bar\" } Use the state command to query the entire state of a stream. Command $ ceramic state kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa You should use your StreamID instead of the StreamID included here. Output before anchor { \"type\" : 0 , \"content\" : { \"Foo\" : \"Bar\" } , \"metadata\" : { \"unique\" : \"E4qPslUd0qo98TZX\" , \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/24/2021, 11:45:00 AM\" } Here we can see various information about the stream such as content , controllers , and schema . In your output you should see your local DID as the controller, instead of the DID we show here. You will also see a different randomly-generated \"unique\" string for any TileDocument that was created without the --deterministic flag. We can also see the current anchorStatus of our stream, and that it has been scheduled to be anchored at 11:45 on the 24 th of January 2021. Once this anchor is finalized, the state of the stream will automatically be updated with a new entry in the log and anchorStatus will be set to ANCHORED . Output after anchor { \"type\" : 0 , \"content\" : { \"Foo\" : \"Bar\" } , \"metadata\" : { \"unique\" : \"E4qPslUd0qo98TZX\" , \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"ANCHORED\" , \"log\" : [ { \"cid\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"type\" : 0 } , { \"cid\" : \"bafyreig6hostufw42cmz2cnn7hpvb6pau67a2n2syhzej7orqxfymdayyq\" , \"type\" : 2 } ] , \"anchorScheduledFor\" : null, \"anchorProof\" : { \"root\" : \"bagcqceranhr345kxf5gb3kwjvvnnefn2krqvhkpnurphqrn3lj773mfszmza\" , \"txHash\" : \"bagjqcgza4xgkpjodtqtgyu2fx6rdr6fb6mhevd5hy4253tl6pjlssidpwaha\" , \"chainId\" : \"eip155:3\" , \"blockNumber\" : 9527752 , \"blockTimestamp\" : 1611485094 } } This output was seen after the anchor has been created. The stream state has now shifted anchorStatus to ANCHORED . You can also see that the log contains one more entry.","title":"Query a stream"},{"location":"build/quick-start/#update-a-stream","text":"Use the update command to update a stream. Your DID must be the controller of the stream in order to update it. Note that TileDocument is the only stream type that can currently be updated by the CLI. Command $ ceramic update kjzl6cwe1jw147ww5d8pswh1hjh686mut8v1br10dar8l9a3n1wf8z38l0bg8qa --content '{ \"Foo\": \"Baz\" }' You should use your StreamID instead of the StreamID included here. Output { \"Foo\" : \"Baz\" } More options Currently you can change content , controllers , and schema using the CLI. Run ceramic update -h for more information.","title":"Update a stream"},{"location":"build/quick-start/#create-a-schema","text":"Ceramic TileDocuments can enforce that their contents adhere to a specified schema. The schemas themselves are Ceramic TileDocuments where the content is a json-schema . For example we can create a schema that requires a document to have a title and message . Command $ ceramic create tile --content ' { \"$schema\": \"http://json-schema.org/draft-07/schema#\", \"title\": \"Reward\", \"type\": \"object\", \"properties\": { \"title\": { \"type\": \"string\" }, \"message\": { \"type\": \"string\" } }, \"required\": [ \"message\", \"title\" ] }' Output StreamID ( kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb ) { \"type\" : \"object\" , \"title\" : \"Reward\" , \" $schema \" : \"http://json-schema.org/draft-07/schema#\" , \"required\" : [ \"message\" , \"title\" ] , \"properties\" : { \"title\" : { \"type\" : \"string\" } , \"message\" : { \"type\" : \"string\" } } }","title":"Create a schema"},{"location":"build/quick-start/#create-a-tiledocument-that-uses-a-schema","text":"First, use the commits command to list the commitIDs contained in the schema document. When creating a TileDocument that uses this schema, we need to use a commitID instead of the DocID to enforce that we are using a specific version of the schema since the schema document is mutable and can be updated. Command $ ceramic commits kjzl6cwe1jw1472as4pj3b3ahqmkokbmwc7jchqcob6pcixcoo4kxq6ls8uuxgb You should use your StreamID for the stream containing the json-schema you want to enforce, instead of the StreamID included here. Output [ \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" ] If a stream contains multiple commits and you're not sure which one you want, use the show command to show the content of the stream at the given commit. Once you retrieve the desired commit, you can now create a TileDocument that is enforced to conform to this version of the schema. Use the create command and pass the --schema option along with your commitID. Command $ ceramic create tile --content '{ \"title\": \"My first document with schema\", \"message\": \"Hello World\" }' --schema k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8 You should use your commitID instead of the commitID included here. Output StreamID ( kjzl6cwe1jw149tvfh6otqfzd2hfknkifb1z2lakozkicvau0xldzzdzwfbsztj ) { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" }","title":"Create a TileDocument that uses a schema"},{"location":"build/quick-start/#query-the-document-you-created","text":"Use the state command to query the state of the TileDocument we just created. We can see that the schema is set to the correct commitID. Command $ ceramic state kjzl6cwe1jw14b5sr79heovz7fziz4dxcn8upx3bcesriloqcui137k6rq6g2mn You should use your StreamID instead of the StreamID included here. Output { \"type\" : 0 , \"content\" : { \"title\" : \"My first document with schema\" , \"message\" : \"Hello World\" } , \"metadata\" : { \"unique\" : \"GR5tBtHdaw608esV\" , \"schema\" : \"k3y52l7qbv1frxu8co1hjrivem5cj2oiqtytlku3e4vjo92l67fkkvu6ywuzfxvy8\" , \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera5qxg5zabjjvwpcbia6c3t6vebgo4brgmsagxezdjgk4vxnzwb5hq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"1/13/2021, 1:45:00 PM\" }","title":"Query the document you created"},{"location":"build/quick-start/#thats-it","text":"Congratulations on completing this tutorial! You're well on your way to becoming a Ceramic developer. Now let's install Ceramic in your project \u2192","title":"That's it!"},{"location":"build/share/","text":"Share your project \u00b6 Congratulations on making it this far! We're excited to see what you've built with Ceramic. To help the community discover your work: Add the ceramic topic to your project on Github Add your project to the Awesome Ceramic page on Github","title":"Share your work"},{"location":"build/share/#share-your-project","text":"Congratulations on making it this far! We're excited to see what you've built with Ceramic. To help the community discover your work: Add the ceramic topic to your project on Github Add your project to the Awesome Ceramic page on Github","title":"Share your project"},{"location":"build/troubleshooting/","text":"Troubleshooting \u00b6 Developer Chat \u00b6 For developer questions, chat, and support, join us on the Ceramic Discord . Github Issues \u00b6 For specific bugs, issues, and feature requests, create a Github issue on the appropriate repository. Before creating a new issue, please search existing issues to ensure your issue has not already been reported. If it has, just add a new comment to that issue explaining that you are encourering the same problem. Twitter \u00b6 For updates and news from the Ceramic ecosystem, follow Ceramic on Twitter .","title":"Troubleshooting"},{"location":"build/troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"build/troubleshooting/#developer-chat","text":"For developer questions, chat, and support, join us on the Ceramic Discord .","title":"Developer Chat"},{"location":"build/troubleshooting/#github-issues","text":"For specific bugs, issues, and feature requests, create a Github issue on the appropriate repository. Before creating a new issue, please search existing issues to ensure your issue has not already been reported. If it has, just add a new comment to that issue explaining that you are encourering the same problem.","title":"Github Issues"},{"location":"build/troubleshooting/#twitter","text":"For updates and news from the Ceramic ecosystem, follow Ceramic on Twitter .","title":"Twitter"},{"location":"build/writes/","text":"Writes \u00b6 Writes are interactions that write to Ceramic, such as creating new streams or modifying existing streams. All write operations are StreamType specific, and the APIs for performing writes are contained within the various Stream implementations. See StreamTypes for information on how to perform writes for each of the supported Stream types. Prerequisites \u00b6 You need an installed client , a configured DID , and an authenticated user to perform writes to the network during runtime.","title":"Writes"},{"location":"build/writes/#writes","text":"Writes are interactions that write to Ceramic, such as creating new streams or modifying existing streams. All write operations are StreamType specific, and the APIs for performing writes are contained within the various Stream implementations. See StreamTypes for information on how to perform writes for each of the supported Stream types.","title":"Writes"},{"location":"build/writes/#prerequisites","text":"You need an installed client , a configured DID , and an authenticated user to perform writes to the network during runtime.","title":"Prerequisites"},{"location":"learn/blog/","text":"Ceramic Blog \u00b6 The Ceramic Blog contains news, announcements, videos, as well as helpful tutorials and resources for building with Ceramic. Check it out to get inspired for your next project. Featured posts \u00b6 What is Ceramic : Ceramic is a decentralized content computation network for a world of open source information. Ceramic Mainnet Early Launch Program : Sign up today to deploy your project on the Ceramic Mainnet before it's open to the general public. How to build a simple notes app with IDX : Learn how to build a simple note taking application where users own their data with IDX and React. How to store signed and encrypted data on IPFS : Learn how to store signed and encrypted data directly in IPFS using two new standards: dag-jose and EIP-2844. Trust minimized off-chain conviction voting : How to implement a conviction voting system using verifiable, off-chain data on Ceramic. Featured videos \u00b6 Learn how to manage user data in a Web3 app with IDX : Learn how to manage user data for your Web3 application with IDX. This talk is a workshop from tthe ETHDenver 2021 hackathon. Standards for encrypted and mutable data on IPFS : Joel talks about new standards for signed, encrypted, mutable data on IPFS. This is a talk from the ETHDenver 2021 hackathon. The evolution of digital identity : Michael talks about the evolution of digital identity from servers, to key pairs, to DIDs and IDX. A presentation from the ETHDever 2021 hackathon.","title":"Blog"},{"location":"learn/blog/#ceramic-blog","text":"The Ceramic Blog contains news, announcements, videos, as well as helpful tutorials and resources for building with Ceramic. Check it out to get inspired for your next project.","title":"Ceramic Blog"},{"location":"learn/blog/#featured-posts","text":"What is Ceramic : Ceramic is a decentralized content computation network for a world of open source information. Ceramic Mainnet Early Launch Program : Sign up today to deploy your project on the Ceramic Mainnet before it's open to the general public. How to build a simple notes app with IDX : Learn how to build a simple note taking application where users own their data with IDX and React. How to store signed and encrypted data on IPFS : Learn how to store signed and encrypted data directly in IPFS using two new standards: dag-jose and EIP-2844. Trust minimized off-chain conviction voting : How to implement a conviction voting system using verifiable, off-chain data on Ceramic.","title":"Featured posts"},{"location":"learn/blog/#featured-videos","text":"Learn how to manage user data in a Web3 app with IDX : Learn how to manage user data for your Web3 application with IDX. This talk is a workshop from tthe ETHDenver 2021 hackathon. Standards for encrypted and mutable data on IPFS : Joel talks about new standards for signed, encrypted, mutable data on IPFS. This is a talk from the ETHDenver 2021 hackathon. The evolution of digital identity : Michael talks about the evolution of digital identity from servers, to key pairs, to DIDs and IDX. A presentation from the ETHDever 2021 hackathon.","title":"Featured videos"},{"location":"learn/overview/","text":"Overview \u00b6 Ceramic is a public, permissionless, open source protocol that provides computation, state transformations, and consensus for all types of data structures stored on the decentralized web. Ceramic's stream processing enables developers to build secure, trustless, censorship-resistant applications on top of dynamic information without trusted database servers. This overview introduces how: Decentralized content computation gives rise to a new era of open source information Stream processing provides an appropriate framework for dynamic, decentralized content You can use Ceramic to replace your database with a truly decentralized alternative To skip ahead and get started building, try the Playground to demo Ceramic in a browser application, the Quick Start guide to learn the basics using the Ceramic CLI, or follow the Installation page to integrate Ceramic into your project. The internet of open source information \u00b6 At its core, the internet is a collection of applications running on stateful data sources \u2013 from identity systems and user tables to databases and feeds for storing all kinds of content generated by users, services, or machines. Most of the information on today's internet is locked away on application-specific database servers designed to protect data as a proprietary resource. Acting as a trusted middleman, applications make it difficult and opaque for others to access this information by requiring explicit permissions, one-off API integrations, and trust that returned state is correct. This siloed and competitive environment results in more friction for developers and worse experiences for users. Along other dimensions, the web has rapidly evolved into a more open source, composable, and collaborative ecosystem. We can observe this trend in open source software enabled by Git's distributed version control and in open source finance enabled by blockchain's double-spend protection. The same principles of open source have not yet been applied to content. The next wave of transformative innovation will be in applying the same open source principles to the world's information, unlocking a universe of content that can be frictionlessly shared across application or organizational boundaries. Achieving this requires a decentralized computation network designed specifically for content with flexibility, scalability, and composability as first class requirements. Decentralized content computation \u00b6 Open sourcing the content layer for applications requires deploying information to a public, permissionless environment where files can be stored, computation can be performed, state can be tracked, and others can easily access content. Advancements in other Web3 protocols have already achieved success in decentralized file storage. As a universal file system for the decentralized web, IPFS (including IPLD and Libp2p ) provides an extremely flexible content naming and routing system. As a storage disk, durable persistence networks (such as Filecoin , Arweave , and Sia ) ensure that the content represented in IPFS files are persisted and kept available. This stack of Web3 protocols performs well for storing static files, but on its own lacks the computation and state management capacity for more advanced database-like features such as mutability, version control, access control, and programmable logic. These are required to enable developers to build fully-featured decentralized applications. Ceramic enables static files to be composed into higher-order mutable data structures, programmed to behave in any desired manner, and whose resulting state is stored and replicated across a decentralized network of nodes. Ceramic builds upon and extends the IPFS file system and underlying persistence networks, as well as other open standards in the decentralized ecosystem, with a general-purpose decentralized content computation substrate. Due to Ceramic's permissionless design and unified global network, anyone in the world can openly create, discover, query, and build upon existing data without needing to trust a centralized server, integrate one-off APIs, or worry if the state of information being returned is correct. Streams \u00b6 Ceramic's decentralized content computation network is modeled after various stream processing frameworks found in Web2. In these types of systems, events are ingested, processed as they arrive, and the resulting output is applied to a log. When queried and reduced, this log represents the current state of a piece of information. This is an appropriate framework for conceptualizing how dynamic information should be modeled on the decentralized web. Furthermore because the function that processes incoming events on any particular stream can be custom written with logic for any use case, it provides the general-purpose flexibility and extensibility needed to represent the diversity of information that may exist on the web. On Ceramic, each piece of information is represented as an append-only log of commits, called a Stream . Each stream is a DAG stored in IPLD, with an immutable name called a StreamID , and a verifiable state called a StreamState . Streams are similar in concept to Git trees, and each stream can be thought of as its own blockchain, ledger, or event log. StreamTypes \u00b6 Each stream must specify a StreamType , which is the processing logic used by the particular stream. A StreamType is essentially a function that is executed by a Ceramic node upon receipt of a new commit to the stream that governs the stream's state transitions and resulting output. StreamTypes are responsible for enforcing all rules and logic for the stream, such as data structure, content format, authentication or access control, and consensus algorithm. If an update does not conform to the logic specified by the StreamType, the update is disregarded. After applying a valid commit to the stream, the resulting StreamState is broadcast out to the rest of the nodes on the Ceramic Network. Each of the other nodes that are also maintaining this stream will update their StreamState to reflect this new transaction. Ceramic's flexible StreamTypes framework enables developers to deploy any kind of information that conforms to any set of arbitrary rules as a stateful stream of events. Ceramic clients come pre-packaged with a standard set of StreamTypes that cover a wide range of common use cases, making it easy to get started building applications: Tile Document: a StreamType that stores a JSON document, providing similar functionality as a NoSQL document store. Tile Documents are frequently used as a database replacement for identity metadata (profiles, social graphs, reputation scores, linked social accounts), user-generated content (blog posts, social media, etc), indexes of other StreamIDs to form collections and user tables (IDX), DID documents, verifiable claims, and more. Tile Documents rely on DIDs for authentication and all valid updates to a stream must be signed by the DID that controls the stream. CAIP-10 Link: a StreamType that stores a cryptographically verifiable proof that links a blockchain address to a DID. A DID can have an unlimited number of CAIP-10 Links that bind it to many different addresses on many different blockchain networks. CAIP-10 Links also rely on DIDs for authentication, same as the Tile Document. Custom: You can implement your own StreamType and deploy it to your Ceramic node if the pre-packaged StreamTypes are not suitable for your use case. Authentication \u00b6 StreamTypes are able to specify their authentication requirements for how new data is authorized to be added to a particular stream. Different StreamTypes may choose to implement different authentication requirements. One of the most powerful and important authentication mechanisms that Ceramic StreamTypes support is DIDs , the W3C standard for decentralized identifiers. DIDs are used by the default StreamTypes (Tile Documents and CAIP-10 Links). DIDs provide a way to go from a globally-unique, platform-agnostic string identifier to a DID document containing public keys for signature verification and encryption. Ceramic is capable of supporting any DID method implementation. Below, find the DID methods that are currently supported by Ceramic: 3ID DID Method : A DID method that uses Ceramic's Tile Document StreamType to represent a mutable DID document. 3IDs are typically used for end-user accounts. When 3IDs are used in conjunction with IDX and the 3ID Keychain (as is implemented in 3ID Connect ), a 3ID can easily be controlled with any number of blockchain accounts from any L1 or L2 network. This provides a way to unify a user's identity across all other platforms. Key DID Method : A DID method statically generated from any Ed25519 key pair. Key DIDs are typically used for developer accounts. Key DID is lightweight, but the drawback is that its DID document is immutable and has no ability to rotate keys if it is compromised. NFT DID Method (coming soon) : A DID method for any NFT on any blockchain. The DID document is statically generated from on-chain data. The DID associated to the blockchain account of the asset's current owner (using CAIP-10 Links) is the only entity authorized to act on behalf of the NFT DID, authenticate in DID-based systems, and make updates to streams or other data owned by the NFT DID. When owenership of the NFT changes, so does the controller permissions. Safe DID Method (coming soon) : A DID method for a Gnosis Safe smart contract on any blockchain. Typically used for organizations, DAOs, and other multi-sig entities. Ceramic Network \u00b6 The Ceramic Network is a decentralized, worldwide network of nodes running the Ceramic protocol that communicate over a dedicated topic on the Libp2p peer-to-peer networking protocol. Ceramic is able to achieve maximum horizontal scalability, throughput, and performance due to its unique design. Sharded execution environment \u00b6 Unlike traditional blockchain systems where scalability is limited to a single global virtual execution environment (VM) and the state of a single ledger is shared between all nodes, each Ceramic node acts as an individual execution environment for performing computations and validating transactions on streams \u2013 there is no global ledger. This \"built-in\" execution sharding enables the Ceramic Network to scale horizontally to parallelize the processing of an increasing number of simultaneous stream transactions as the number of nodes on the network increases. Such a design is needed to handle the scale of the world's data, which is orders of magnitude greater than the throughput needed on a financial blockchain. Another benefit of this design is that a Ceramic node can perform stream transactions in an offline-first environment and then later sync updates with the rest of the network when it comes back online. Global namespace \u00b6 Since all nodes are part of the same Ceramic Network, every stream on Ceramic exists within a single global namespace where it can be accessed by any other node or referenced by any other stream. This creates a public data web of open source information. Additional node responsibilities \u00b6 In addition to executing stream transactions according to StreamType logic, Ceramic nodes also maintain a few other key responsibilities: StreamState storage: A Ceramic node only persists StreamStates for the streams it cares to keep around, a process called \"pinning.\" Different nodes will maintain StreamStates for different streams, but multiple nodes can maintain the state of a single stream. Commit log storage: A Ceramic node maintains a local copy of all commits to the streams it is pinning. Persistence connectors: Ceramic nodes can optionally utilize an additional durable storage backend for backing up commits for streams it is pinning. This can be any of the persistence networks mentioned above, including Filecoin, Arweave, Sia, etc. (coming soon). Query responses: Ceramic nodes respond to stream queries from clients. If the node has the stream pinned it will return the response; if not, it will ask the rest of the network for the stream over libp2p and then return the response. Broadcasting transactions: When a Ceramic node successfully performs a transaction on a stream, it broadcasts this transaction out the rest of the network over libp2p so other nodes also pinning this stream can update their StreamState to reflect this new transaction. Clients \u00b6 Clients provide standard interfaces for performing transactions and queries on streams, and are installed into applications. Clients are also responsible for authenticating users and signing transactions. Currently there are three clients for Ceramic. Additional client implementations can easily be developed in other programming languages: JS HTTP client: A lightweight JavaScript client which connects to a remote Ceramic node over HTTP. The JS HTTP client is recommended for application developers. JS Core client: A JavaScript client which also includes a full Ceramic node. The JS Core client is for those who want the maximum decentralization of running the full Ceramic protocol directly in a browser application. CLI: A command line interface for interacting with a Ceramic node. Getting started \u00b6 Try Ceramic \u00b6 To experience how Ceramic works in a browser application, try the Playground app. Installation \u00b6 Getting started with Ceramic is simple. Visit the Quick Start guide to learn the basics using the Ceramic CLI or follow the Installation page to integrate Ceramic into your project. Tools and services \u00b6 In addition to various standards referenced throughout this document, the Ceramic community has already begun delevoping many different open source protocols, tools, and services that simplify the experience of developing on Ceramic. Here are a few notable examples: 3ID Connect: A authentication SDK for browser-based applications that allows your users to transact with Ceramic using their blockchain wallet. IDX: A protocol for decentralized identity that allows a DID to aggregate an index of all their data from across all apps in one place. IDX enables user-centric data storage, discovery, and interoperability. It is effectively a decentralized, cross-platform user table. IDX can reference all data source types, including Ceramic streams and other peer-to-peer databases and files. IdentityLink: A service that issues verifiable claims which prove a DID owns various other Web2 social accounts such as Twitter, Github, Discord, Discourse, Telegram, Instagram, etc. Once issued, claims are stored in the DID's IDX. Documint: A browser-based IDE for creating and editing streams. Tiles: An explorer for the Ceramic Network.","title":"Overview"},{"location":"learn/overview/#overview","text":"Ceramic is a public, permissionless, open source protocol that provides computation, state transformations, and consensus for all types of data structures stored on the decentralized web. Ceramic's stream processing enables developers to build secure, trustless, censorship-resistant applications on top of dynamic information without trusted database servers. This overview introduces how: Decentralized content computation gives rise to a new era of open source information Stream processing provides an appropriate framework for dynamic, decentralized content You can use Ceramic to replace your database with a truly decentralized alternative To skip ahead and get started building, try the Playground to demo Ceramic in a browser application, the Quick Start guide to learn the basics using the Ceramic CLI, or follow the Installation page to integrate Ceramic into your project.","title":"Overview"},{"location":"learn/overview/#the-internet-of-open-source-information","text":"At its core, the internet is a collection of applications running on stateful data sources \u2013 from identity systems and user tables to databases and feeds for storing all kinds of content generated by users, services, or machines. Most of the information on today's internet is locked away on application-specific database servers designed to protect data as a proprietary resource. Acting as a trusted middleman, applications make it difficult and opaque for others to access this information by requiring explicit permissions, one-off API integrations, and trust that returned state is correct. This siloed and competitive environment results in more friction for developers and worse experiences for users. Along other dimensions, the web has rapidly evolved into a more open source, composable, and collaborative ecosystem. We can observe this trend in open source software enabled by Git's distributed version control and in open source finance enabled by blockchain's double-spend protection. The same principles of open source have not yet been applied to content. The next wave of transformative innovation will be in applying the same open source principles to the world's information, unlocking a universe of content that can be frictionlessly shared across application or organizational boundaries. Achieving this requires a decentralized computation network designed specifically for content with flexibility, scalability, and composability as first class requirements.","title":"The internet of open source information"},{"location":"learn/overview/#decentralized-content-computation","text":"Open sourcing the content layer for applications requires deploying information to a public, permissionless environment where files can be stored, computation can be performed, state can be tracked, and others can easily access content. Advancements in other Web3 protocols have already achieved success in decentralized file storage. As a universal file system for the decentralized web, IPFS (including IPLD and Libp2p ) provides an extremely flexible content naming and routing system. As a storage disk, durable persistence networks (such as Filecoin , Arweave , and Sia ) ensure that the content represented in IPFS files are persisted and kept available. This stack of Web3 protocols performs well for storing static files, but on its own lacks the computation and state management capacity for more advanced database-like features such as mutability, version control, access control, and programmable logic. These are required to enable developers to build fully-featured decentralized applications. Ceramic enables static files to be composed into higher-order mutable data structures, programmed to behave in any desired manner, and whose resulting state is stored and replicated across a decentralized network of nodes. Ceramic builds upon and extends the IPFS file system and underlying persistence networks, as well as other open standards in the decentralized ecosystem, with a general-purpose decentralized content computation substrate. Due to Ceramic's permissionless design and unified global network, anyone in the world can openly create, discover, query, and build upon existing data without needing to trust a centralized server, integrate one-off APIs, or worry if the state of information being returned is correct.","title":"Decentralized content computation"},{"location":"learn/overview/#streams","text":"Ceramic's decentralized content computation network is modeled after various stream processing frameworks found in Web2. In these types of systems, events are ingested, processed as they arrive, and the resulting output is applied to a log. When queried and reduced, this log represents the current state of a piece of information. This is an appropriate framework for conceptualizing how dynamic information should be modeled on the decentralized web. Furthermore because the function that processes incoming events on any particular stream can be custom written with logic for any use case, it provides the general-purpose flexibility and extensibility needed to represent the diversity of information that may exist on the web. On Ceramic, each piece of information is represented as an append-only log of commits, called a Stream . Each stream is a DAG stored in IPLD, with an immutable name called a StreamID , and a verifiable state called a StreamState . Streams are similar in concept to Git trees, and each stream can be thought of as its own blockchain, ledger, or event log.","title":"Streams"},{"location":"learn/overview/#streamtypes","text":"Each stream must specify a StreamType , which is the processing logic used by the particular stream. A StreamType is essentially a function that is executed by a Ceramic node upon receipt of a new commit to the stream that governs the stream's state transitions and resulting output. StreamTypes are responsible for enforcing all rules and logic for the stream, such as data structure, content format, authentication or access control, and consensus algorithm. If an update does not conform to the logic specified by the StreamType, the update is disregarded. After applying a valid commit to the stream, the resulting StreamState is broadcast out to the rest of the nodes on the Ceramic Network. Each of the other nodes that are also maintaining this stream will update their StreamState to reflect this new transaction. Ceramic's flexible StreamTypes framework enables developers to deploy any kind of information that conforms to any set of arbitrary rules as a stateful stream of events. Ceramic clients come pre-packaged with a standard set of StreamTypes that cover a wide range of common use cases, making it easy to get started building applications: Tile Document: a StreamType that stores a JSON document, providing similar functionality as a NoSQL document store. Tile Documents are frequently used as a database replacement for identity metadata (profiles, social graphs, reputation scores, linked social accounts), user-generated content (blog posts, social media, etc), indexes of other StreamIDs to form collections and user tables (IDX), DID documents, verifiable claims, and more. Tile Documents rely on DIDs for authentication and all valid updates to a stream must be signed by the DID that controls the stream. CAIP-10 Link: a StreamType that stores a cryptographically verifiable proof that links a blockchain address to a DID. A DID can have an unlimited number of CAIP-10 Links that bind it to many different addresses on many different blockchain networks. CAIP-10 Links also rely on DIDs for authentication, same as the Tile Document. Custom: You can implement your own StreamType and deploy it to your Ceramic node if the pre-packaged StreamTypes are not suitable for your use case.","title":"StreamTypes"},{"location":"learn/overview/#authentication","text":"StreamTypes are able to specify their authentication requirements for how new data is authorized to be added to a particular stream. Different StreamTypes may choose to implement different authentication requirements. One of the most powerful and important authentication mechanisms that Ceramic StreamTypes support is DIDs , the W3C standard for decentralized identifiers. DIDs are used by the default StreamTypes (Tile Documents and CAIP-10 Links). DIDs provide a way to go from a globally-unique, platform-agnostic string identifier to a DID document containing public keys for signature verification and encryption. Ceramic is capable of supporting any DID method implementation. Below, find the DID methods that are currently supported by Ceramic: 3ID DID Method : A DID method that uses Ceramic's Tile Document StreamType to represent a mutable DID document. 3IDs are typically used for end-user accounts. When 3IDs are used in conjunction with IDX and the 3ID Keychain (as is implemented in 3ID Connect ), a 3ID can easily be controlled with any number of blockchain accounts from any L1 or L2 network. This provides a way to unify a user's identity across all other platforms. Key DID Method : A DID method statically generated from any Ed25519 key pair. Key DIDs are typically used for developer accounts. Key DID is lightweight, but the drawback is that its DID document is immutable and has no ability to rotate keys if it is compromised. NFT DID Method (coming soon) : A DID method for any NFT on any blockchain. The DID document is statically generated from on-chain data. The DID associated to the blockchain account of the asset's current owner (using CAIP-10 Links) is the only entity authorized to act on behalf of the NFT DID, authenticate in DID-based systems, and make updates to streams or other data owned by the NFT DID. When owenership of the NFT changes, so does the controller permissions. Safe DID Method (coming soon) : A DID method for a Gnosis Safe smart contract on any blockchain. Typically used for organizations, DAOs, and other multi-sig entities.","title":"Authentication"},{"location":"learn/overview/#ceramic-network","text":"The Ceramic Network is a decentralized, worldwide network of nodes running the Ceramic protocol that communicate over a dedicated topic on the Libp2p peer-to-peer networking protocol. Ceramic is able to achieve maximum horizontal scalability, throughput, and performance due to its unique design.","title":"Ceramic Network"},{"location":"learn/overview/#sharded-execution-environment","text":"Unlike traditional blockchain systems where scalability is limited to a single global virtual execution environment (VM) and the state of a single ledger is shared between all nodes, each Ceramic node acts as an individual execution environment for performing computations and validating transactions on streams \u2013 there is no global ledger. This \"built-in\" execution sharding enables the Ceramic Network to scale horizontally to parallelize the processing of an increasing number of simultaneous stream transactions as the number of nodes on the network increases. Such a design is needed to handle the scale of the world's data, which is orders of magnitude greater than the throughput needed on a financial blockchain. Another benefit of this design is that a Ceramic node can perform stream transactions in an offline-first environment and then later sync updates with the rest of the network when it comes back online.","title":"Sharded execution environment"},{"location":"learn/overview/#global-namespace","text":"Since all nodes are part of the same Ceramic Network, every stream on Ceramic exists within a single global namespace where it can be accessed by any other node or referenced by any other stream. This creates a public data web of open source information.","title":"Global namespace"},{"location":"learn/overview/#additional-node-responsibilities","text":"In addition to executing stream transactions according to StreamType logic, Ceramic nodes also maintain a few other key responsibilities: StreamState storage: A Ceramic node only persists StreamStates for the streams it cares to keep around, a process called \"pinning.\" Different nodes will maintain StreamStates for different streams, but multiple nodes can maintain the state of a single stream. Commit log storage: A Ceramic node maintains a local copy of all commits to the streams it is pinning. Persistence connectors: Ceramic nodes can optionally utilize an additional durable storage backend for backing up commits for streams it is pinning. This can be any of the persistence networks mentioned above, including Filecoin, Arweave, Sia, etc. (coming soon). Query responses: Ceramic nodes respond to stream queries from clients. If the node has the stream pinned it will return the response; if not, it will ask the rest of the network for the stream over libp2p and then return the response. Broadcasting transactions: When a Ceramic node successfully performs a transaction on a stream, it broadcasts this transaction out the rest of the network over libp2p so other nodes also pinning this stream can update their StreamState to reflect this new transaction.","title":"Additional node responsibilities"},{"location":"learn/overview/#clients","text":"Clients provide standard interfaces for performing transactions and queries on streams, and are installed into applications. Clients are also responsible for authenticating users and signing transactions. Currently there are three clients for Ceramic. Additional client implementations can easily be developed in other programming languages: JS HTTP client: A lightweight JavaScript client which connects to a remote Ceramic node over HTTP. The JS HTTP client is recommended for application developers. JS Core client: A JavaScript client which also includes a full Ceramic node. The JS Core client is for those who want the maximum decentralization of running the full Ceramic protocol directly in a browser application. CLI: A command line interface for interacting with a Ceramic node.","title":"Clients"},{"location":"learn/overview/#getting-started","text":"","title":"Getting started"},{"location":"learn/overview/#try-ceramic","text":"To experience how Ceramic works in a browser application, try the Playground app.","title":"Try Ceramic"},{"location":"learn/overview/#installation","text":"Getting started with Ceramic is simple. Visit the Quick Start guide to learn the basics using the Ceramic CLI or follow the Installation page to integrate Ceramic into your project.","title":"Installation"},{"location":"learn/overview/#tools-and-services","text":"In addition to various standards referenced throughout this document, the Ceramic community has already begun delevoping many different open source protocols, tools, and services that simplify the experience of developing on Ceramic. Here are a few notable examples: 3ID Connect: A authentication SDK for browser-based applications that allows your users to transact with Ceramic using their blockchain wallet. IDX: A protocol for decentralized identity that allows a DID to aggregate an index of all their data from across all apps in one place. IDX enables user-centric data storage, discovery, and interoperability. It is effectively a decentralized, cross-platform user table. IDX can reference all data source types, including Ceramic streams and other peer-to-peer databases and files. IdentityLink: A service that issues verifiable claims which prove a DID owns various other Web2 social accounts such as Twitter, Github, Discord, Discourse, Telegram, Instagram, etc. Once issued, claims are stored in the DID's IDX. Documint: A browser-based IDE for creating and editing streams. Tiles: An explorer for the Ceramic Network.","title":"Tools and services"},{"location":"learn/welcome/","text":"Ceramic Developers \u00b6 Welcome to the Ceramic developer site. Whether you want to learn how the Ceramic protocol works, explore standards and tooling, or get started building, this site has the resources for you. Learn \u00b6 Overview : Learn about Ceramic's decentralized content computation protocol Try \u00b6 Playground : A demo application that uses Ceramic with 3ID Connect and IDX in a web browser Tiles : A Ceramic network explorer Build \u00b6 Quick start : Get up to speed on the basics using the CLI Installation : Install Ceramic in your project Standards and tools \u00b6 StreamTypes : Various StreamTypes developed by the community Schemas : Useful data models to help you get started DIDs : DID methods that can be used for authentication IDX : A protocol and framework for identity-centric data management IdentityLink : A service that issues verifiable claims which link a DID to various Web2 social accounts 3ID Connect : An SDK that allows users to authenticate their DID with various blockchain wallets Community \u00b6 Join the Discord to ask questions and engage with the community Follow us on Twitter for updates Read the blog for news, announcements, and tutorials","title":"Welcome"},{"location":"learn/welcome/#ceramic-developers","text":"Welcome to the Ceramic developer site. Whether you want to learn how the Ceramic protocol works, explore standards and tooling, or get started building, this site has the resources for you.","title":"Ceramic Developers"},{"location":"learn/welcome/#learn","text":"Overview : Learn about Ceramic's decentralized content computation protocol","title":"Learn"},{"location":"learn/welcome/#try","text":"Playground : A demo application that uses Ceramic with 3ID Connect and IDX in a web browser Tiles : A Ceramic network explorer","title":"Try"},{"location":"learn/welcome/#build","text":"Quick start : Get up to speed on the basics using the CLI Installation : Install Ceramic in your project","title":"Build"},{"location":"learn/welcome/#standards-and-tools","text":"StreamTypes : Various StreamTypes developed by the community Schemas : Useful data models to help you get started DIDs : DID methods that can be used for authentication IDX : A protocol and framework for identity-centric data management IdentityLink : A service that issues verifiable claims which link a DID to various Web2 social accounts 3ID Connect : An SDK that allows users to authenticate their DID with various blockchain wallets","title":"Standards and tools"},{"location":"learn/welcome/#community","text":"Join the Discord to ask questions and engage with the community Follow us on Twitter for updates Read the blog for news, announcements, and tutorials","title":"Community"},{"location":"learn/dids/methods/","text":"","title":"Methods"},{"location":"learn/dids/providers/","text":"","title":"Providers"},{"location":"learn/dids/resolvers/","text":"","title":"Resolvers"},{"location":"learn/dids/specification/","text":"","title":"Specification"},{"location":"learn/dids/wallets/","text":"","title":"Wallets"},{"location":"learn/documents/docids/","text":"","title":"Docids"},{"location":"learn/documents/document-log/","text":"","title":"Document log"},{"location":"learn/documents/document-model/","text":"Documents \u00b6 Data model \u00b6 The document log is the core underlying data structure for each Ceramic document. It contains a complete history of all updates to the document and its state can be verified by anyone by applying all previously valid transactions in the log. Document log \u00b6 The document log is the core underlying data structure for each Ceramic document. It contains a complete history of all updates to the document and its state can be verified by anyone by applying all previously valid transactions in the log. DocID \u00b6 DocIDs are uniue identifiers for documents on the Ceramic network. Specification lorem ipsum Example lorem ipsum Records \u00b6 VersionID \u00b6 Tips \u00b6 Tips are the current state of a document, represented by its most recent versionID. Metadata \u00b6 Metadata is information that lives in the header of the document. Doctypes \u00b6 Doctypes are drivers for documents on the Ceramic network. They are responsible for specifying core functionality including content requirements and consensus rules. Every document must specify which doctype it is using. Controllers \u00b6 Controllers is a required metadata property for all documents which specifies who is allowed to make updates to the document. If an entity is not included as a controller, its updates to the document will be disregarded by the protocol. The types of controllers allowed is specified by the doctype . For example tile doctypes allow DIDs as controllers, while CAIP-10 links allow blockchain addresses. Schemas \u00b6 Schemas are an optional metadata property allowed by certain doctypes, such as the tile doctype , which specifies the format and shape of the document's content. All updates to documents that specify a schema must conform to that schema; if not, those updates will be disregarded by the protocol. Schemas themselves are created as documents on Ceramic and the DocID of that schema document should be included in the schema metadata property for the document you are creating. Family \u00b6 Family is an optional metadata property for documets that is used to identify groups of related documents on the network. Tags \u00b6 Tags are optional metadata properties for documets that are used for various classifications. These are flexible and can be used to categorize information in a number of ways. Deterministic \u00b6 Deterministic is an optional metadata boolean that defaults to false. When set to true it omits a random number from being added to the genesis record which allows you to recreate the same genesis record if you create a record with the same metadata and content. Content \u00b6 The content of your document can be anything that is permitted by the doctype specified in the document's metadata. For example the tile doctype allows any JSON content, while the CAIP-10 link doctype is much more strict on allowable content.","title":"Documents"},{"location":"learn/documents/document-model/#documents","text":"","title":"Documents"},{"location":"learn/documents/document-model/#data-model","text":"The document log is the core underlying data structure for each Ceramic document. It contains a complete history of all updates to the document and its state can be verified by anyone by applying all previously valid transactions in the log.","title":"Data model"},{"location":"learn/documents/document-model/#document-log","text":"The document log is the core underlying data structure for each Ceramic document. It contains a complete history of all updates to the document and its state can be verified by anyone by applying all previously valid transactions in the log.","title":"Document log"},{"location":"learn/documents/document-model/#docid","text":"DocIDs are uniue identifiers for documents on the Ceramic network. Specification lorem ipsum Example lorem ipsum","title":"DocID"},{"location":"learn/documents/document-model/#records","text":"","title":"Records"},{"location":"learn/documents/document-model/#versionid","text":"","title":"VersionID"},{"location":"learn/documents/document-model/#tips","text":"Tips are the current state of a document, represented by its most recent versionID.","title":"Tips"},{"location":"learn/documents/document-model/#metadata","text":"Metadata is information that lives in the header of the document.","title":"Metadata"},{"location":"learn/documents/document-model/#doctypes","text":"Doctypes are drivers for documents on the Ceramic network. They are responsible for specifying core functionality including content requirements and consensus rules. Every document must specify which doctype it is using.","title":"Doctypes"},{"location":"learn/documents/document-model/#controllers","text":"Controllers is a required metadata property for all documents which specifies who is allowed to make updates to the document. If an entity is not included as a controller, its updates to the document will be disregarded by the protocol. The types of controllers allowed is specified by the doctype . For example tile doctypes allow DIDs as controllers, while CAIP-10 links allow blockchain addresses.","title":"Controllers"},{"location":"learn/documents/document-model/#schemas","text":"Schemas are an optional metadata property allowed by certain doctypes, such as the tile doctype , which specifies the format and shape of the document's content. All updates to documents that specify a schema must conform to that schema; if not, those updates will be disregarded by the protocol. Schemas themselves are created as documents on Ceramic and the DocID of that schema document should be included in the schema metadata property for the document you are creating.","title":"Schemas"},{"location":"learn/documents/document-model/#family","text":"Family is an optional metadata property for documets that is used to identify groups of related documents on the network.","title":"Family"},{"location":"learn/documents/document-model/#tags","text":"Tags are optional metadata properties for documets that are used for various classifications. These are flexible and can be used to categorize information in a number of ways.","title":"Tags"},{"location":"learn/documents/document-model/#deterministic","text":"Deterministic is an optional metadata boolean that defaults to false. When set to true it omits a random number from being added to the genesis record which allows you to recreate the same genesis record if you create a record with the same metadata and content.","title":"Deterministic"},{"location":"learn/documents/document-model/#content","text":"The content of your document can be anything that is permitted by the doctype specified in the document's metadata. For example the tile doctype allows any JSON content, while the CAIP-10 link doctype is much more strict on allowable content.","title":"Content"},{"location":"learn/documents/tips/","text":"","title":"Tips"},{"location":"learn/network/anchor-services/","text":"","title":"Anchor services"},{"location":"learn/network/clients/","text":"Network Overview \u00b6 Ceramic is a decentralized network of nodes that run the Ceramic protocol. Clients \u00b6 Clients are software that provide API access to Ceramic nodes. They allow interactions with the Ceramic network. Responsibilities \u00b6 API Interface \u00b6 Authenticate users \u00b6 Sign records \u00b6 Add more \u00b6 Client Implementations \u00b6 HTTP Client JS Client CLI Client Nodes \u00b6 Nodes are software that run the Ceramic protocol and form a peer-to-peer network with other nodes. Networking \u00b6 Network connection \u00b6 Nodes must specify which Ceramic network they are connecting to. This configuration allows the node to mesh with all other nodes connected to the same network. Gossip updates \u00b6 Nodes must specify which Ceramic network they are connecting to. This configuration allows the node to mesh with all other nodes connected to the same network. Query responses \u00b6 Nodes are responsible for responding to queries about any document that it has. If the node has the document in its cache it will respond directly, but if if doesn't have it, it will ask other nodes on the network for it using libp2p. Storage \u00b6 Loading documents \u00b6 Nodes can ask other nodes for a document and it will sync it from the network and load it in memory. This includes the entire document log (contents) and its most recent tip (state). Caching/Pinning documents \u00b6 Ceramic nodes use an instance of IPFS for short-term pinning/caching the documents that they care about. For each document that it cares about, a node will cache its document log and its tip. Nodes cache the Ceramic nodes come prepackaged with an internal IPFS node, but an externally run IPFS node may be used instead. (add something in here about garbage collection?) Persistence coordination \u00b6 Ceramic nodes may optionally specify one or more external service(s) for the long-term storage of documents. If specified, the node is responsible for forwarding document records to this service. Learn more about persistence options. Transactions \u00b6 Authentication (??) \u00b6 Nodes take a DID provider instance and allow that authenticated user to perform transactions. Record validation \u00b6 Nodes receive records (from clients (or anchor services?)) and then validate that these records conform to the rules of the document's specified doctype. Record application \u00b6 Nodes apply only valid records to the document's document log. Invalid or malformed records are discarded. Anchor service coordination \u00b6 After applying a genesis record or signed record to the document log, nodes then send these records to the HTTP endpoint of an anchor service which anchors it in a blockchain. After successfully anchoring the record, the anchor service sends back an anchor record over libp2p which is then applied to the document log by the node. Conflict resolution \u00b6 Should this be its own category, or should this live elsewhere? Anchor Services \u00b6 Responsibilities \u00b6 Blockchain anchoring \u00b6 The primary responsibility of an anchor service is to generate anchor records by committing signed records into a blockchain. All of the responsibilities below are in service of this primary responsibility. Merkle tree construction \u00b6 Constructs a merkle tree of all signed records that eill be simultaneously committed to a blockchain in a single hash, called a merkle root. Anchor metadata \u00b6 Bloom filter, helps with indexing services. Anchor status messages \u00b6 Sends messages to the pubsub room specified for the Ceramic network that the anchor service is servicing. This allows Ceramic nodesLearn more about anchor status messages.","title":"Network Overview"},{"location":"learn/network/clients/#network-overview","text":"Ceramic is a decentralized network of nodes that run the Ceramic protocol.","title":"Network Overview"},{"location":"learn/network/clients/#clients","text":"Clients are software that provide API access to Ceramic nodes. They allow interactions with the Ceramic network.","title":"Clients"},{"location":"learn/network/clients/#responsibilities","text":"","title":"Responsibilities"},{"location":"learn/network/clients/#client-implementations","text":"HTTP Client JS Client CLI Client","title":"Client Implementations"},{"location":"learn/network/clients/#nodes","text":"Nodes are software that run the Ceramic protocol and form a peer-to-peer network with other nodes.","title":"Nodes"},{"location":"learn/network/clients/#networking","text":"","title":"Networking"},{"location":"learn/network/clients/#storage","text":"","title":"Storage"},{"location":"learn/network/clients/#transactions","text":"","title":"Transactions"},{"location":"learn/network/clients/#anchor-services","text":"","title":"Anchor Services"},{"location":"learn/network/clients/#responsibilities_1","text":"","title":"Responsibilities"},{"location":"learn/network/nodes/","text":"","title":"Nodes"},{"location":"reference/http-api/","text":"HTTP API \u00b6 The HTTP API allows you to manually make HTTP requests that create, modify, and query streams on a remote Ceramic node. If you are building an application, you will usually interact with a node using one of the Ceramic clients , however this documentation is useful if: You have a special use case where you directly want to use HTTP requests You want to implement an HTTP client in a new language Gateway mode Not all of the API methods are available if the Ceramic node runs in gateway mode . This option disables writes, which is useful when exposing your node to the internet. Methods disabled in gateway mode will be clearly marked. Streams \u00b6 The stream endpoint is used to create new streams and to load streams from their StreamID or from their genesis content. Get stream state \u00b6 Load the state of a stream given its StreamID. Request GET /api/v0/streams/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response The response body contains the following fields: streamId - the StreamID of the requested stream as string state - the state of the requested stream as StreamState Example \u00b6 Request $ curl http://localhost:7007/api/v0/streams/kjzl6cwe1jw147r7878h32yazawcll6bxe5v92348cxitif6cota91qp68grbhm Response { \"streamId\" : \"kjzl6cwe1jw147r7878h32yazawcll6bxe5v92348cxitif6cota91qp68grbhm\" , \"state\" : { \"type\" : 0 , \"content\" : { \"Ceramic\" : \"pottery\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [{ \"cid\" : \"bagcqceramof2xi7kh6qblirzkbc7yulcjcticlcob6uvdrx3bexgks37ilva\" , \"type\" : 0 }] , \"anchorScheduledFor\" : \"12/15/2020, 2:45:00 PM\" } } Create stream \u00b6 Disabled in gateway mode Create a new stream, or load a stream from its genesis content. The genesis content may be signed (a DagJWS for streams of type TileDocument), or unsigned in some cases. Request POST /api/v0/streams Request body fields: \u00b6 type - the type code of the streamtype to use (e.g. 0 for TileDocuments). Type codes for the supported stream types can be found in this table . genesis - the genesis content of the stream (will differ per streamtype) opts - options for the stream creation, CreateOpts (optional) Response The response body contains the following fields: streamId - the StreamID of the requested stream as string state - the state of the requested stream as StreamState Example \u00b6 This example creates a TileDocument from an unsigned genesis commit. Note that if the content is defined for a TileDocument genesis commit, it needs to be signed. Request $ curl http://localhost:7007/api/v0/streams -X POST -d '{ \"type\": 0, \"genesis\": { \"header\": { \"family\": \"test\", \"controllers\": [\"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\"] } } }' -H \"Content-Type: application/json\" Response { \"streamId\" : \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" , \"state\" : { \"type\" : 0 , \"content\" : {} , \"metadata\" : { \"family\" : \"test\" , \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 0 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bafyreihtdxfb6cpcvomm2c2elm3re2onqaix6frq4nbg45eaqszh5mifre\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/15/2020, 3:00:00 PM\" } } Multiqueries \u00b6 The multiqueries endpoint enables querying multiple streams at once, as well as querying streams which are linked. Query multiple streams \u00b6 This endpoint allows you to query multiple StreamIDs. Along with each StreamID an array of paths can be passed. If any of the paths within the stream structure contains a Ceramic StreamID url ( ceramic://<StreamID> ), this linked stream will also be returned as part of the response. Request POST /api/v0/multiqueries Request body fields: \u00b6 queries - an array of MultiQuery objects Response The response body contains a map from StreamID strings to StreamState objects. Example \u00b6 First let's create three streams to query using the ceramic cli: Request1 $ ceramic create tile --content '{ \"Document\": \"A\" }' Response1 StreamID ( kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc ) { \"Document\" : \"A\" } Request2 $ ceramic create tile --content '{ \"Document\": \"B\" }' Response2 StreamID ( kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0 ) { \"Document\" : \"B\" } Request3 $ ceramic create tile --content '{ \"Document\": \"C\", \"link\": \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" }' Response3 StreamID ( kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl ) { \"link\" : \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" , \"Document\" : \"C\" } Now let's query them though the multiqueries endpoint: Request $ curl http://localhost:7007/api/v0/multiqueries -X POST -d '{ \"queries\": [{ \"streamId\": \"kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl\", \"paths\": [\"link\"] }, { \"streamId\": \"kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0\", \"paths\": [] }] }' -H \"Content-Type: application/json\" Response { \"kjzl6cwe1jw14b54pb10voc4bqh73qyu8o6cfu66hoi3feidbbj81i5rohh7kgl\" : { \"type\" : 0 , \"content\" : { \"link\" : \"ceramic://kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" , \"Document\" : \"C\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera5nx45nccxvjjyxsq3so5po77kpqzbfsydy6yflnkt6p5tnjvhbkq\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:45:00 PM\" } , \"kjzl6cwe1jw149rledowj0zi0icd7epi9y1m5tx4pardt1w6dzcxvr6bohi8ejc\" : { \"type\" : 0 , \"content\" : { \"Document\" : \"A\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcerawq5h7otlkdwuai7vhogqhs2aeaauwbu2aqclrh4iyu5h54qqogma\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:45:00 PM\" } , \"kjzl6cwe1jw147w3xz3xrcd37chh2rz4dfra3imtnsni385rfyqa3hbx42qwal0\" : { \"type\" : 0 , \"content\" : { \"Document\" : \"B\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqceranecdjzw4xheudgkr2amjkntpktci2xv44d7v4hbft3ndpptid6ka\" , \"type\" : 0 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:45:00 PM\" } } Commits \u00b6 The commits endpoint provides lower level access to the data structure of a Ceramic stream. It is also the enpoint that is used in order to update a stream, by adding a new commit. Get all stream commits \u00b6 By calling GET on the commits endpoint along with a StreamID gives you access to all of the commits of the given stream. This is useful if you want to inspect the stream history, or apply all of the commits to a Ceramic node that is not connected to the network. Request GET /api/v0/commits/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response streamId - the StreamID of the requested stream, string commits - an array of commit objects Example \u00b6 Request $ curl http://localhost:7007/api/v0/commits/kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv Response { \"streamId\" : \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\" , \"commits\" : [ { \"cid\" : \"bagcqcera2faj5vik2giftqxftbngfndkci7x4z5vp3psrf4flcptgkz5xztq\" , \"value\" : { \"jws\" : { \"payload\" : \"AXESIAsUBpZMnue1yQ0BgXsjOFyN0cHq6AgspXnI7qGB54ux\" , \"signatures\" : [ { \"signature\" : \"16tBnfkXQU0yo-RZvfjWhm7pP-hIxJ5m-FIMHlCrRkpjbleoEcaC80Xt7qs_WZOlOCexznjow9aX4aZe51cYCQ\" , \"protected\" : \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\" } ] , \"link\" : \"bafyreialcqdjmte64624sdibqf5sgoc4rxi4d2xibawkk6oi52qydz4lwe\" } , \"linkedBlock\" : \"o2RkYXRhoWV0aXRsZXFNeSBmaXJzdCBEb2N1bWVudGZoZWFkZXKiZnNjaGVtYfZrY29udHJvbGxlcnOBeDhkaWQ6a2V5Ono2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SGZ1bmlxdWVwenh0b1A5blphdVgxcEE0OQ\" } } , { \"cid\" : \"bagcqcera3fkje7je4lvctkam4fvi675avtcuqgrv7dn6aoqljd5lebpl7rfq\" , \"value\" : { \"jws\" : { \"payload\" : \"AXESINm6lI30m3j5H2ausx-ulXj-L9CmFlOTZBZvJ2O734Zt\" , \"signatures\" : [ { \"signature\" : \"zsLJbBSU5xZTQkYlXwEH9xj_t_8frvSFCYs0SlVMPXOnw8zOJOsKnJDQlUOvPJxjt8Bdc_7xoBdmcRG1J1tpCw\" , \"protected\" : \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\" } ] , \"link\" : \"bafyreigzxkki35e3pd4r6zvowmp25fly7yx5bjqwkojwiftpe5r3xx4gnu\" } , \"linkedBlock\" : \"pGJpZNgqWCYAAYUBEiDRQJ7VCtGQWcLlmFpitGoSP35ntX7fKJeFWJ8zKz2+Z2RkYXRhgaNib3BjYWRkZHBhdGhlL21vcmVldmFsdWUY6mRwcmV22CpYJgABhQESINFAntUK0ZBZwuWYWmK0ahI/fme1ft8ol4VYnzMrPb5nZmhlYWRlcqFrY29udHJvbGxlcnOA\" } } ] } Apply a commit to stream \u00b6 Disabled in gateway mode In order to modify a stream we apply a commit to its log. This commit usually contains a signature over a json-patch diff describing a modification to the stream contents. The commit also needs to contain pointers to the previous commit and other metadata. You can read more about this in the Ceramic Specification . Different stream types may have different formats for their commits. If you want to see an example implementation for how to construct a commit you can have a look at the implementation of the TileDocument. Request POST /api/v0/commits Request body fields: \u00b6 streamId - the StreamID of the stream to apply the commit to, string commit - the content of the commit to apply (will differ per streamtype) opts - options for the stream update UpdateOpts (optional) Response streamId - the StreamID of the stream that was modified state - the new state of the stream that was modified, StreamState Example \u00b6 Request $ curl http://localhost:7007/api/v0/commits -X POST -d '{ \"streamId\": \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\", \"commit\": { \"jws\": { \"payload\": \"AXESINm6lI30m3j5H2ausx-ulXj-L9CmFlOTZBZvJ2O734Zt\", \"signatures\": [ { \"signature\": \"zsLJbBSU5xZTQkYlXwEH9xj_t_8frvSFCYs0SlVMPXOnw8zOJOsKnJDQlUOvPJxjt8Bdc_7xoBdmcRG1J1tpCw\", \"protected\": \"eyJhbGciOiJFZERTQSIsImtpZCI6ImRpZDprZXk6ejZNa2ZaNlM0TlZWVEV1dHM4bzV4RnpSTVI4ZUM2WTFibmdvQlFOblhpQ3ZoSDhII3o2TWtmWjZTNE5WVlRFdXRzOG81eEZ6Uk1SOGVDNlkxYm5nb0JRTm5YaUN2aEg4SCJ9\" } ], \"link\": \"bafyreigzxkki35e3pd4r6zvowmp25fly7yx5bjqwkojwiftpe5r3xx4gnu\" }, \"linkedBlock\": \"pGJpZNgqWCYAAYUBEiDRQJ7VCtGQWcLlmFpitGoSP35ntX7fKJeFWJ8zKz2+Z2RkYXRhgaNib3BjYWRkZHBhdGhlL21vcmVldmFsdWUY6mRwcmV22CpYJgABhQESINFAntUK0ZBZwuWYWmK0ahI/fme1ft8ol4VYnzMrPb5nZmhlYWRlcqFrY29udHJvbGxlcnOA\" } }' -H \"Content-Type: application/json\" Response { \"streamId\" : \"kjzl6cwe1jw14ahmwunhk9yjwawac12tb52j1uj3b9a57eohmhycec8778p3syv\" , \"state\" : { \"type\" : 0 , \"content\" : { \"title\" : \"My first Document\" } , \"metadata\" : { \"schema\" : null, \"controllers\" : [ \"did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H\" ] } , \"signature\" : 2 , \"anchorStatus\" : \"PENDING\" , \"log\" : [ { \"cid\" : \"bagcqcera2faj5vik2giftqxftbngfndkci7x4z5vp3psrf4flcptgkz5xztq\" , \"type\" : 0 } , { \"cid\" : \"bagcqcera3fkje7je4lvctkam4fvi675avtcuqgrv7dn6aoqljd5lebpl7rfq\" , \"type\" : 1 } ] , \"anchorScheduledFor\" : \"12/30/2020, 1:15:00 PM\" , \"next\" : { \"content\" : { \"title\" : \"My first Document\" , \"more\" : 234 } , \"metadata\" : { \"schema\" : null, \"controllers\" : [] } } } } Pins \u00b6 The pins api endpoint can be used to manipulate the pinset. The pinset is all of the streams that a node maintains the state of. Any stream opened by the node that is not pinned will eventually be garbage collected from the node. Add to pinset \u00b6 Disabled in gateway mode This method adds the stream with the given StreamID to the pinset. Request POST /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response If the operation was sucessful the response will be a 200 OK. streamId - the StreamID of the stream which was pinned, string Example \u00b6 Request $ curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl -X POST Response { \"streamId\" : \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" } Remove from pinset \u00b6 Disabled in gateway mode This method removes the stream with the given StreamID from the pinset. Request DELETE /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response If the operation was sucessful the response will be a 200 OK. streamId - the StreamID of the stream which was unpinned, string Example \u00b6 Request $ curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl -X DELETE Response { \"streamId\" : \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" } List streams in pinset \u00b6 Calling this method allows you to list all of the streams that are in the pinset on this node. Request GET /api/v0/pins Response pinnedStreamIds - an array of StreamID strings that are in the pinset Example \u00b6 Request $ curl http://localhost:7007/api/v0/pins Response { \"pinnedStreamIds\" : [ \"k2t6wyfsu4pfwqaju0w9nmi53zo6f5bcier7vc951x4b9rydv6t8q4pvzd5w3l\" , \"k2t6wyfsu4pfxon8reod8xcyka9bujeg7acpz8hgh0jsyc7p2b334izdyzsdp7\" , \"k2t6wyfsu4pfxqseec01fnqywmn8l93p4g2chzyx3sod3hpyovurye9hskcegs\" , \"k2t6wyfsu4pfya9y0ega1vnokf0g5qaus69basy52oxg50y3l35vm9rqbb88t3\" ] } Confirm stream in pinset \u00b6 This method is used to check if a particular stream is in the pinset. Request GET /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response pinnedStreamIds - an array containing the specified StreamID string if that stream is pinned, or an empty array if that stream is not pinned Example \u00b6 Request $ curl http://localhost:7007/api/v0/pins/k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl Response { \"pinnedStreamIds\" : [ \"k2t6wyfsu4pg2qvoorchoj23e8hf3eiis4w7bucllxkmlk91sjgluuag5syphl\" ] } Node Info \u00b6 The methods under the /node path provides more information about this particular node. Supported blockchains for anchoring \u00b6 Get all of the CAIP-2 chainIds supported by this node. Request GET /api/v0/node/chains Response The response body contains the following fields: supportedChains - and array with CAIP-2 formatted chainIds Example \u00b6 Request $ curl http://localhost:7007/api/v0/node/chains Response { \"supportedChains\" : [ \"eip155:3\" ] } Health check \u00b6 Check the health of the node and the machine it's running on. Run ceramic daemon -h for more details on how this can be configured. Request GET /api/v0/node/healthcheck Response Either a 200 response with the text Alive! , or a 503 with the text Insufficient resources . Example \u00b6 Request $ curl http://localhost:7007/api/v0/node/healthcheck Response Alive!","title":"HTTP API"},{"location":"reference/http-api/#http-api","text":"The HTTP API allows you to manually make HTTP requests that create, modify, and query streams on a remote Ceramic node. If you are building an application, you will usually interact with a node using one of the Ceramic clients , however this documentation is useful if: You have a special use case where you directly want to use HTTP requests You want to implement an HTTP client in a new language Gateway mode Not all of the API methods are available if the Ceramic node runs in gateway mode . This option disables writes, which is useful when exposing your node to the internet. Methods disabled in gateway mode will be clearly marked.","title":"HTTP API"},{"location":"reference/http-api/#streams","text":"The stream endpoint is used to create new streams and to load streams from their StreamID or from their genesis content.","title":"Streams"},{"location":"reference/http-api/#get-stream-state","text":"Load the state of a stream given its StreamID. Request GET /api/v0/streams/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response The response body contains the following fields: streamId - the StreamID of the requested stream as string state - the state of the requested stream as StreamState","title":"Get stream state"},{"location":"reference/http-api/#create-stream","text":"Disabled in gateway mode Create a new stream, or load a stream from its genesis content. The genesis content may be signed (a DagJWS for streams of type TileDocument), or unsigned in some cases. Request POST /api/v0/streams","title":"Create stream"},{"location":"reference/http-api/#multiqueries","text":"The multiqueries endpoint enables querying multiple streams at once, as well as querying streams which are linked.","title":"Multiqueries"},{"location":"reference/http-api/#query-multiple-streams","text":"This endpoint allows you to query multiple StreamIDs. Along with each StreamID an array of paths can be passed. If any of the paths within the stream structure contains a Ceramic StreamID url ( ceramic://<StreamID> ), this linked stream will also be returned as part of the response. Request POST /api/v0/multiqueries","title":"Query multiple streams"},{"location":"reference/http-api/#commits","text":"The commits endpoint provides lower level access to the data structure of a Ceramic stream. It is also the enpoint that is used in order to update a stream, by adding a new commit.","title":"Commits"},{"location":"reference/http-api/#get-all-stream-commits","text":"By calling GET on the commits endpoint along with a StreamID gives you access to all of the commits of the given stream. This is useful if you want to inspect the stream history, or apply all of the commits to a Ceramic node that is not connected to the network. Request GET /api/v0/commits/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response streamId - the StreamID of the requested stream, string commits - an array of commit objects","title":"Get all stream commits"},{"location":"reference/http-api/#apply-a-commit-to-stream","text":"Disabled in gateway mode In order to modify a stream we apply a commit to its log. This commit usually contains a signature over a json-patch diff describing a modification to the stream contents. The commit also needs to contain pointers to the previous commit and other metadata. You can read more about this in the Ceramic Specification . Different stream types may have different formats for their commits. If you want to see an example implementation for how to construct a commit you can have a look at the implementation of the TileDocument. Request POST /api/v0/commits","title":"Apply a commit to stream"},{"location":"reference/http-api/#pins","text":"The pins api endpoint can be used to manipulate the pinset. The pinset is all of the streams that a node maintains the state of. Any stream opened by the node that is not pinned will eventually be garbage collected from the node.","title":"Pins"},{"location":"reference/http-api/#add-to-pinset","text":"Disabled in gateway mode This method adds the stream with the given StreamID to the pinset. Request POST /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response If the operation was sucessful the response will be a 200 OK. streamId - the StreamID of the stream which was pinned, string","title":"Add to pinset"},{"location":"reference/http-api/#remove-from-pinset","text":"Disabled in gateway mode This method removes the stream with the given StreamID from the pinset. Request DELETE /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response If the operation was sucessful the response will be a 200 OK. streamId - the StreamID of the stream which was unpinned, string","title":"Remove from pinset"},{"location":"reference/http-api/#list-streams-in-pinset","text":"Calling this method allows you to list all of the streams that are in the pinset on this node. Request GET /api/v0/pins Response pinnedStreamIds - an array of StreamID strings that are in the pinset","title":"List streams in pinset"},{"location":"reference/http-api/#confirm-stream-in-pinset","text":"This method is used to check if a particular stream is in the pinset. Request GET /api/v0/pins/:streamid Here, :streamid should be replaced by the string representation of the StreamID of the stream that is being requested. Response pinnedStreamIds - an array containing the specified StreamID string if that stream is pinned, or an empty array if that stream is not pinned","title":"Confirm stream in pinset"},{"location":"reference/http-api/#node-info","text":"The methods under the /node path provides more information about this particular node.","title":"Node Info"},{"location":"reference/http-api/#supported-blockchains-for-anchoring","text":"Get all of the CAIP-2 chainIds supported by this node. Request GET /api/v0/node/chains Response The response body contains the following fields: supportedChains - and array with CAIP-2 formatted chainIds","title":"Supported blockchains for anchoring"},{"location":"reference/http-api/#health-check","text":"Check the health of the node and the machine it's running on. Run ceramic daemon -h for more details on how this can be configured. Request GET /api/v0/node/healthcheck Response Either a 200 response with the text Alive! , or a 503 with the text Insufficient resources .","title":"Health check"},{"location":"reference/javascript/anchor-service/","text":"Anchor Service (CAS) \u00b6 The Ceramic Anchor Service (CAS) is a hosted layer 2 scalability solution for batching many Ceramic transactions into a single blockchain transaction. For details about the JavaScript CAS implementation and how to run it, refer to its repo: Ceramic Anchor Service","title":"Anchor Service"},{"location":"reference/javascript/anchor-service/#anchor-service-cas","text":"The Ceramic Anchor Service (CAS) is a hosted layer 2 scalability solution for batching many Ceramic transactions into a single blockchain transaction. For details about the JavaScript CAS implementation and how to run it, refer to its repo: Ceramic Anchor Service","title":"Anchor Service (CAS)"},{"location":"reference/javascript/blockchain/","text":"Add support for a new blockchain \u00b6 This document contains a guide on how to add support for a new blockchain to the Caip10Link StreamType, and to use it for authentication in Ceramic. Ceramic and blockchain accounts \u00b6 Ceramic interacts with blockchain accounts in two ways: authentication and linking . Authentication \u00b6 3ID Connect (using 3id-did-provider ) creates 3id (Ceramic flavour of DID) private keys based on an externally-provided entropy. It could be provided by a blockchain account by merely signing a well-known message. From a user's standpoint, it is authentication into Ceramic through her blockchain account, be it on Ethereum, Filecoin, EOS, Cosmos or something else. Same signature (=same entropy) generates same Ceramic DID. Linking \u00b6 In addition to generating a DID a user could also link additional blockchain accounts to a Ceramic DID. It establishes a relation blockchain account \u2192 DID that allows one to discover a DID (and associated data like a social profile and data) based on just a blockchain account. Additionally, a link serves as a proof-of-ownership by DID over the blockchain account. This is useful for dApp personalization and UX: one sees familiar names instead of 0xgibberish . Below one additional process is mentioned: validation. It checks if proof-of-ownership in the link is formally correct, i.e., a well-known payload is really signed by the account that is declared in the link. Adding a new blockchain \u00b6 To add a new blockchain to Ceramic one has to implement both linking and validation. We use CAIP-10 to represent accounts in a blockchain agnostic way. If the blockchain you want to add isn't already part of the CAIP standards you should make sure to add it there. Linking \u00b6 To add a new blockchain, one has to implement a new class implementing AuthProvider , put it into the @ceramicnetwork/blockchain-utils-linking package and export it. The auth provider sits between 3id-connect (or 3ID DID Provider) and your blockchain account provider. In case of Ethereum, it might be MetaMask. It is responsible mainly for: authentication ( #authenticate ): provide deterministic entropy creating link ( #createLink ): create a LinkProof object which associates the specified AccountID with a DID The auth provider is expected to know which blockchain account it currently serves. It reports it via #accountId . To reuse the same internal settings, e.g. a connection to a blockchain provider, but with a different account, the auth provider should have a #withAddress method. Let's look at each method required to be implemented by the AuthProvider interface: authenticate() \u00b6 The authenticate function allows a blockchain account to be added as an authentication method (authMethod) to a 3ID. This means using your blockchain account you will always be able to access that 3ID and derive its 3ID Keychain for use, for example in 3ID Connect. Parameters \u00b6 message : string, can be any string AccountID : an instance of a CAIP-10 AccountID provider : specific to your blockchain. This is any standard signer or provider defined for your blockchain. Ideally your ecosystem has a widely-accepted standard interface so that this module can support signing by most accounts. Returns \u00b6 entropy : a hex string representing 32 bytes of entropy, prefixed by 0x The entropy returned by a given AccountID must always be the same. createLink() \u00b6 The createLink function allows a blockchain account to create a verifiable link proof that publicly binds the blockchain account to a given DID. In Ceramic, these these link proofs can be used to create CAIP10Link streams which allow anyone to look up the DID linked to your blockchain account, and then resolve any other public info linked to your DID. The StreamIDs of your CAIP10Links can be stored in the IDX Crypto Accounts records for simple lookup. This function consumes similar arguments as described above. It also consumes the DID string that is being linked. This function is implemented such that when the given AccountID signs a message including the given DID with the given provider, a LinkProof is returned. accountId() \u00b6 The accountId method should return currently used account in the CAIP-10 format. withAccount() \u00b6 The withAccount method should return a new instance of the auth provider that serves a new account. Validation \u00b6 Validation is the counterpart of linking that checks if the signature contained in a LinkProof corresponds to the declared account. To add support for a new blockchain: add a new file named after your blockchain to @ceramicnetwork/blockchain-utils-validation package this file should expose an implementation of the BlockchainHandler interface, having: CAIP-2 namespace for your blockchain a validateLink function that checks if the linking signature was created by the account declared in the LinkProof argument add the newly created BlockchainHandler to the handlers list in index.ts validateLink() \u00b6 The validateLink function validates a given LinkProof. This allows anyone to easily verify LinkProofs and for Ceramic to validate CAIP10Links. The function consumes a LinkProof and returns the LinkProof if valid, otherwise it returns null. Valid typically means that the given signature in the LinkProof is valid over the given message and is created by the given account. Make sure that validateLink can validate links created by AuthProvider#createLink . Currently supported blockchains \u00b6 Below you can see a table which lists supported blockchains and their provider objects. If you add support for a new chain, please make a PR here. Blockchain CAIP-2 namespace Supported providers Notes Cosmos cosmos cosmos provider The Cosmos wallet provider interface is still being standardized and is subject to change. Ethereum eip155 metamask-like ethereum provider Filecoin fil Filecoin Wallet Provider EOS eosio @smontero/eosio-local-provider Polkadot polkadot @polkadot{.js} extention api Doesn't support the authenticate method yet.","title":"Support new Blockchain"},{"location":"reference/javascript/blockchain/#add-support-for-a-new-blockchain","text":"This document contains a guide on how to add support for a new blockchain to the Caip10Link StreamType, and to use it for authentication in Ceramic.","title":"Add support for a new blockchain"},{"location":"reference/javascript/blockchain/#ceramic-and-blockchain-accounts","text":"Ceramic interacts with blockchain accounts in two ways: authentication and linking .","title":"Ceramic and blockchain accounts"},{"location":"reference/javascript/blockchain/#authentication","text":"3ID Connect (using 3id-did-provider ) creates 3id (Ceramic flavour of DID) private keys based on an externally-provided entropy. It could be provided by a blockchain account by merely signing a well-known message. From a user's standpoint, it is authentication into Ceramic through her blockchain account, be it on Ethereum, Filecoin, EOS, Cosmos or something else. Same signature (=same entropy) generates same Ceramic DID.","title":"Authentication"},{"location":"reference/javascript/blockchain/#linking","text":"In addition to generating a DID a user could also link additional blockchain accounts to a Ceramic DID. It establishes a relation blockchain account \u2192 DID that allows one to discover a DID (and associated data like a social profile and data) based on just a blockchain account. Additionally, a link serves as a proof-of-ownership by DID over the blockchain account. This is useful for dApp personalization and UX: one sees familiar names instead of 0xgibberish . Below one additional process is mentioned: validation. It checks if proof-of-ownership in the link is formally correct, i.e., a well-known payload is really signed by the account that is declared in the link.","title":"Linking"},{"location":"reference/javascript/blockchain/#adding-a-new-blockchain","text":"To add a new blockchain to Ceramic one has to implement both linking and validation. We use CAIP-10 to represent accounts in a blockchain agnostic way. If the blockchain you want to add isn't already part of the CAIP standards you should make sure to add it there.","title":"Adding a new blockchain"},{"location":"reference/javascript/blockchain/#linking_1","text":"To add a new blockchain, one has to implement a new class implementing AuthProvider , put it into the @ceramicnetwork/blockchain-utils-linking package and export it. The auth provider sits between 3id-connect (or 3ID DID Provider) and your blockchain account provider. In case of Ethereum, it might be MetaMask. It is responsible mainly for: authentication ( #authenticate ): provide deterministic entropy creating link ( #createLink ): create a LinkProof object which associates the specified AccountID with a DID The auth provider is expected to know which blockchain account it currently serves. It reports it via #accountId . To reuse the same internal settings, e.g. a connection to a blockchain provider, but with a different account, the auth provider should have a #withAddress method. Let's look at each method required to be implemented by the AuthProvider interface:","title":"Linking"},{"location":"reference/javascript/blockchain/#validation","text":"Validation is the counterpart of linking that checks if the signature contained in a LinkProof corresponds to the declared account. To add support for a new blockchain: add a new file named after your blockchain to @ceramicnetwork/blockchain-utils-validation package this file should expose an implementation of the BlockchainHandler interface, having: CAIP-2 namespace for your blockchain a validateLink function that checks if the linking signature was created by the account declared in the LinkProof argument add the newly created BlockchainHandler to the handlers list in index.ts","title":"Validation"},{"location":"reference/javascript/blockchain/#currently-supported-blockchains","text":"Below you can see a table which lists supported blockchains and their provider objects. If you add support for a new chain, please make a PR here. Blockchain CAIP-2 namespace Supported providers Notes Cosmos cosmos cosmos provider The Cosmos wallet provider interface is still being standardized and is subject to change. Ethereum eip155 metamask-like ethereum provider Filecoin fil Filecoin Wallet Provider EOS eosio @smontero/eosio-local-provider Polkadot polkadot @polkadot{.js} extention api Doesn't support the authenticate method yet.","title":"Currently supported blockchains"},{"location":"reference/javascript/clients/","text":"Clients \u00b6 The JavaScript implementation of the Ceramic Protocol consists of two main packages which can be used at runtime in your project, @ceramicnetwork/core and @ceramicnetwork/http-client . Both clients implement the same CeramicApi TypeScript interface. CeramicApi reference Core client \u00b6 The core client allows you to run the full Ceramic protocol (API and node) directly in any JavaScript environment, including directly in-browser. You might use the Core client if you want your project to be maximally decentralized. However, there are tradeoffs such as performance and data availability since this node can go on and offline as the user opens and closes browser windows. Installation | API reference HTTP client \u00b6 The HTTP clent allows you to interact with a remote Ceramic node from any JavaScript environment. The HTTP client is recommended when building most applications. Installation | API reference","title":"Clients"},{"location":"reference/javascript/clients/#clients","text":"The JavaScript implementation of the Ceramic Protocol consists of two main packages which can be used at runtime in your project, @ceramicnetwork/core and @ceramicnetwork/http-client . Both clients implement the same CeramicApi TypeScript interface. CeramicApi reference","title":"Clients"},{"location":"reference/javascript/clients/#core-client","text":"The core client allows you to run the full Ceramic protocol (API and node) directly in any JavaScript environment, including directly in-browser. You might use the Core client if you want your project to be maximally decentralized. However, there are tradeoffs such as performance and data availability since this node can go on and offline as the user opens and closes browser windows. Installation | API reference","title":"Core client"},{"location":"reference/javascript/clients/#http-client","text":"The HTTP clent allows you to interact with a remote Ceramic node from any JavaScript environment. The HTTP client is recommended when building most applications. Installation | API reference","title":"HTTP client"},{"location":"reference/javascript/did-providers/","text":"DID Providers \u00b6 A DID Provider is a library that exposes a json-rpc interface which is consumed by a Ceramic client or other DID compatible software. Usually it is constructed using a seed that the user controls. See the Authentication page for details on how to use DID providers. 3ID DID Provider \u00b6 The 3ID DID Provider allows you to create and manage a 3ID. ceramicstudio/js-3id-did-provider Key DID Provider \u00b6 A Key DID provider allows you to create and use a Key DID. Below you can find a reference implementation of the ed25519 Key DID. ceramicnetwork/key-did-provider-ed25519","title":"DID Providers"},{"location":"reference/javascript/did-providers/#did-providers","text":"A DID Provider is a library that exposes a json-rpc interface which is consumed by a Ceramic client or other DID compatible software. Usually it is constructed using a seed that the user controls. See the Authentication page for details on how to use DID providers.","title":"DID Providers"},{"location":"reference/javascript/did-providers/#3id-did-provider","text":"The 3ID DID Provider allows you to create and manage a 3ID. ceramicstudio/js-3id-did-provider","title":"3ID DID Provider"},{"location":"reference/javascript/did-providers/#key-did-provider","text":"A Key DID provider allows you to create and use a Key DID. Below you can find a reference implementation of the ed25519 Key DID. ceramicnetwork/key-did-provider-ed25519","title":"Key DID Provider"},{"location":"reference/javascript/did-resolvers/","text":"DID Resolvers \u00b6 A DID resolver is a small library that takes a DID string and returns a DID Document. Ceramic uses DID resolvers to verify transactions by comparing the signature on the transaction to the controller of the document. For the transaction to be valid, a public key corresponding to the transaction must be present in the DID Document of the DID listed as a controller. Below you can find references for the main did-resolver package as well as plugins for specific DID Methods. DID Resolver \u00b6 The main library needed to start resolving DIDs is the did-resolver package. It is maintained by the Decentralized Identity Foundation (DIF) and can be found at their github: decentralized-identity/did-resolver Plugins \u00b6 3ID DID Resolver \u00b6 The 3ID DID Method is a DID that is implemented on top of Ceramic using the tile doctype. The 3ID DID resolver uses Ceramic to resolve DIDs. ceramicnetwork/3id-did-resolver Key DID Resolver \u00b6 The Key DID Method is the most simple DID method. It simply encodes a public key in the DID string, and when resolved converts this public key into a DID Document. ceramicnetwork/key-did-resolver did:key specification","title":"DID Resolvers"},{"location":"reference/javascript/did-resolvers/#did-resolvers","text":"A DID resolver is a small library that takes a DID string and returns a DID Document. Ceramic uses DID resolvers to verify transactions by comparing the signature on the transaction to the controller of the document. For the transaction to be valid, a public key corresponding to the transaction must be present in the DID Document of the DID listed as a controller. Below you can find references for the main did-resolver package as well as plugins for specific DID Methods.","title":"DID Resolvers"},{"location":"reference/javascript/did-resolvers/#did-resolver","text":"The main library needed to start resolving DIDs is the did-resolver package. It is maintained by the Decentralized Identity Foundation (DIF) and can be found at their github: decentralized-identity/did-resolver","title":"DID Resolver"},{"location":"reference/javascript/did-resolvers/#plugins","text":"","title":"Plugins"},{"location":"reference/javascript/did-resolvers/#3id-did-resolver","text":"The 3ID DID Method is a DID that is implemented on top of Ceramic using the tile doctype. The 3ID DID resolver uses Ceramic to resolve DIDs. ceramicnetwork/3id-did-resolver","title":"3ID DID Resolver"},{"location":"reference/javascript/did-resolvers/#key-did-resolver","text":"The Key DID Method is the most simple DID method. It simply encodes a public key in the DID string, and when resolved converts this public key into a DID Document. ceramicnetwork/key-did-resolver did:key specification","title":"Key DID Resolver"},{"location":"run/deployment-tools/","text":"","title":"Deployment tools"},{"location":"run/running-a-node/","text":"","title":"Running a node"},{"location":"run/running-an-anchor-service/","text":"","title":"Running an anchor service"},{"location":"streamtypes/overview/","text":"StreamTypes \u00b6 Each Stream in Ceramic is of a specific type. Different StreamTypes can contain different structures of data, and have different APIs for creating, updating, and inspecting them. The currently available StreamTypes are: TileDocument - A JSON Document store for arbitrary application data. Caip10Link - A blockchain account link for publicly linking blockchain addresses to DIDs.","title":"Overview"},{"location":"streamtypes/overview/#streamtypes","text":"Each Stream in Ceramic is of a specific type. Different StreamTypes can contain different structures of data, and have different APIs for creating, updating, and inspecting them. The currently available StreamTypes are: TileDocument - A JSON Document store for arbitrary application data. Caip10Link - A blockchain account link for publicly linking blockchain addresses to DIDs.","title":"StreamTypes"},{"location":"streamtypes/caip-10-link/api/","text":"Caip10Link API \u00b6 This guide demonstrates how to create, update, and query Caip10Links on the Ceramic network using the HTTP and core clients. Prerequisites \u00b6 You need an installed client to read or write Caip10Links on the network during runtime. Create or query a link \u00b6 Use the Caip10Link.fromAccount() method to create a new Caip10Link for a given Caip10 blockchain address, or to look up an existing link for that address. const link = await Caip10Link . fromAccount ( ceramic , accountId , opts ) Creating a new link \u00b6 In this example we create a new empty Caip10Link for the account 0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8 on the Ethereum mainnet blockchain. The newly created Caip10Link will not have any DID associated with it at first. const accountLink = await Caip10Link . fromAccount ( ceramic , '0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8@eip155:1' , ) Note that by default Caip10Link.fromAccount() will try to query the network for the current Stream state. If you know that this is the first time a Caip10Link has been created for this blockchain address, and you wish to avoid waiting on a response from the network unnecessarily, you can set syncTimeoutSeconds to 0 in the opts argument. Loading an existing link \u00b6 In this example we load a Caip10Link for the account 0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8 on the Ethereum mainnet blockchain. const accountLink = await Caip10Link . fromAccount ( ceramic , '0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8@eip155:1' , ) const linkedDid = accountLink . did Note that the examples for creating a new link and for loading an existing link look the same. Caip10Link.fromAccount will create a new link if one doesn't exist, in which case the returned link will have no linked DID associated with it. If the link already exists, however, then Caip10Link.fromAccount will return the current state of the link, which may include a linked DID if one has been set previously. API reference Parameters \u00b6 ceramic \u00b6 When creating or querying a Caip10Link, the first parameter is the CeramicAPI used to communicate with the ceramic node and it is always required. It will either be an instance of Ceramic when using the Core client or an instance of CeramicClient when using the HTTP client. accountId \u00b6 The blockchain account ID - in Caip10 format - of the blockchain account being linked. opts (optional) \u00b6 The final argument to Caip10Link.fromAccount is an instance of CreateOpts , which are options that control network behaviors performed as part of the operation. They are not included in the link itself. Parameter Required? Value Description Default value anchor optional boolean Request an anchor after creating the link true publish optional boolean Publish the new link to the network true sync optional enum Controls behavior related to syncing the current link state from the network SyncOptions.PREFER_CACHE syncTimeoutSeconds optional number How long to wait to hear about the current state of the link from the network 3 API reference Associate a DID with a Caip10Link \u00b6 Use the link.setDid() method to update the DID associated with a given Caip10Link const link = await Caip10Link . fromAccount ( ceramic , accountId , opts ) await link . setDid ( did , authProvider , opts ) Example In this example we create a Caip10Link for the ethereum mainnet account 0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8 and then associate it with the DID did:3:k2t6wyfsu4pg0t2n4j8ms3s33xsgqjhtto04mvq8w5a2v5xo48idyz38l7ydki import { Caip10Link } from '@ceramicnetwork/stream-caip10-link' import { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking' // First, get an ethereum provider for communicating with the ethereum blockchain. // This example assumes you have an ethereum provider available in `window.ethereum`, provided // by the web browser or a browser extension. const ethProvider = window . ethereum // Next use the ethProvider to make an EthereumAuthProvider which can issue LinkProofs linking // addresses on Ethereum to DIDs. const ethAuthProvider = new EthereumAuthProvider ( ethProvider , '0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8' ) const accountId = await ethAuthProvider . accountId () const accountLink = await Caip10Link . fromAccount ( ceramic , accountId ) await accountLink . setDid ( 'did:3:k2t6wyfsu4pg0t2n4j8ms3s33xsgqjhtto04mvq8w5a2v5xo48idyz38l7ydki' , ethAuthProvider ) API reference Parameters \u00b6 did \u00b6 The DID to associate with the caip10 blockchain account represented by this Caip10Link. authProvider \u00b6 An instance of the AuthProvider interface that can create link proofs for the blockchain network that the account this Caip10Link represents lives on. opts (optional) \u00b6 The final argument to Caip10Link.setDid is an instance of UpdateOpts , which are options that control network behaviors performed as part of the operation. Parameter Required? Value Description Default value anchor optional boolean Request an anchor after updating the link true publish optional boolean Publish the update to the network true API reference","title":"API"},{"location":"streamtypes/caip-10-link/api/#caip10link-api","text":"This guide demonstrates how to create, update, and query Caip10Links on the Ceramic network using the HTTP and core clients.","title":"Caip10Link API"},{"location":"streamtypes/caip-10-link/api/#prerequisites","text":"You need an installed client to read or write Caip10Links on the network during runtime.","title":"Prerequisites"},{"location":"streamtypes/caip-10-link/api/#create-or-query-a-link","text":"Use the Caip10Link.fromAccount() method to create a new Caip10Link for a given Caip10 blockchain address, or to look up an existing link for that address. const link = await Caip10Link . fromAccount ( ceramic , accountId , opts )","title":"Create or query a link"},{"location":"streamtypes/caip-10-link/api/#parameters","text":"","title":"Parameters"},{"location":"streamtypes/caip-10-link/api/#associate-a-did-with-a-caip10link","text":"Use the link.setDid() method to update the DID associated with a given Caip10Link const link = await Caip10Link . fromAccount ( ceramic , accountId , opts ) await link . setDid ( did , authProvider , opts ) Example In this example we create a Caip10Link for the ethereum mainnet account 0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8 and then associate it with the DID did:3:k2t6wyfsu4pg0t2n4j8ms3s33xsgqjhtto04mvq8w5a2v5xo48idyz38l7ydki import { Caip10Link } from '@ceramicnetwork/stream-caip10-link' import { EthereumAuthProvider } from '@ceramicnetwork/blockchain-utils-linking' // First, get an ethereum provider for communicating with the ethereum blockchain. // This example assumes you have an ethereum provider available in `window.ethereum`, provided // by the web browser or a browser extension. const ethProvider = window . ethereum // Next use the ethProvider to make an EthereumAuthProvider which can issue LinkProofs linking // addresses on Ethereum to DIDs. const ethAuthProvider = new EthereumAuthProvider ( ethProvider , '0x0544dcf4fce959c6c4f3b7530190cb5e1bd67cb8' ) const accountId = await ethAuthProvider . accountId () const accountLink = await Caip10Link . fromAccount ( ceramic , accountId ) await accountLink . setDid ( 'did:3:k2t6wyfsu4pg0t2n4j8ms3s33xsgqjhtto04mvq8w5a2v5xo48idyz38l7ydki' , ethAuthProvider ) API reference","title":"Associate a DID with a Caip10Link"},{"location":"streamtypes/caip-10-link/api/#parameters_1","text":"","title":"Parameters"},{"location":"streamtypes/caip-10-link/overview/","text":"CAIP-10 Link \u00b6 CAIP-10 Link is a StreamType that stores a cryptographically verifiable proof that links a blockchain address to a DID. Use cases \u00b6 A DID can have an unlimited number of CAIP-10 Links that publicly bind it to many different addresses on many different L1 and L2 blockchain networks. Design \u00b6 Authentication: DIDs Ordering: Anchor records checkpointed into a blockchain (via blockheight) Conflict resolution: Earliest anchor wins (EAW)","title":"Overview"},{"location":"streamtypes/caip-10-link/overview/#caip-10-link","text":"CAIP-10 Link is a StreamType that stores a cryptographically verifiable proof that links a blockchain address to a DID.","title":"CAIP-10 Link"},{"location":"streamtypes/caip-10-link/overview/#use-cases","text":"A DID can have an unlimited number of CAIP-10 Links that publicly bind it to many different addresses on many different L1 and L2 blockchain networks.","title":"Use cases"},{"location":"streamtypes/caip-10-link/overview/#design","text":"Authentication: DIDs Ordering: Anchor records checkpointed into a blockchain (via blockheight) Conflict resolution: Earliest anchor wins (EAW)","title":"Design"},{"location":"streamtypes/tile-document/api/","text":"TileDocument API \u00b6 This guide demonstrates how to create, update, and query TileDocuments on the Ceramic network using the HTTP and core clients. TileDocuments can also be read and written via the CLI, see Quick Start for more information. Prerequisites \u00b6 You need an installed client and an authenticated user to perform writes to TileDocuments on the network during runtime. If you only wish to query existing TileDocuments then you still need an installed client but it doesn't need to be authenticated. Create a document \u00b6 Use the TileDocument.create() method to create a new document. const doc = await TileDocument . create ( ceramic , content , metadata , opts ) Example In this example we create a document where we set content , schema , controllers , and family . const doc = await TileDocument . create ( ceramic , { foo : \"bar\" }, { controllers : [ ceramic . did . id ], family : \"doc family\" , schema : schemaDoc . commitId , } ) API reference Parameters \u00b6 ceramic \u00b6 When creating a TileDocument, the first parameter is the CeramicAPI used to communicate with the ceramic node and it is always required. It will either be an instance of Ceramic when using the Core client or an instance of CeramicClient when using the HTTP client. content \u00b6 The content of your document, in the form of a JSON document. If schema is set in the metadata, then the content must conform to the specified schema. When content is included during document creation, the document's genesis commit will be signed by the authenticated user's DID. When content is omitted (set as null or undefined ), then the genesis commit will not be signed. metadata (optional) \u00b6 Parameter Required? Value Description Notes controllers optional array of strings Defines the DID that is allowed to modify the document. Currently only one controller is supported per document If empty, defaults to currently authenticated DID schema optional string CommitID of a Ceramic TileDocument that contains a JSON schema If set, schema will be enforced on content family optional string Allows you to group similar documents into families Useful for indexing groups of like documents on the network tags optional array of strings Allows you to tag similar documents Useful for indexing groups of like documents on the network deterministic optional boolean If false, allows TileDocuments with the same content and metadata to generate unique StreamIDs If empty, defaults to false API reference Using the deterministic parameter For most use cases you will likely want to leave the deterministic parameter set to false. However for special circumstances, you may want this to be set to true. For example this should be set to true if you would like to enable deterministic queries for your document. If this is your use case, then it is also important that you set content to null during document creation. Deterministic document queries are based entirely on the document's initial metadata. You can proceed to add content to your document by updating it . API reference opts (optional) \u00b6 The final argument to TileDocument.create is an instance of CreateOpts , which are options that control network behaviors performed as part of the operation. They are not included in the document itself. Parameter Required? Value Description Default value anchor optional boolean Request an anchor after creating the document true publish optional boolean Publish the new document to the network true sync optional enum Controls behavior related to syncing the current document state from the network PREFER_CACHE syncTimeoutSeconds optional number How long to wait to hear about the current state of the document from the network 3 for deterministic documents, 0 otherwise API reference Update a document \u00b6 Use the doc.update() method to update the content or metadata of an existing TileDocument. const doc = await TileDocument . load ( ceramic , streamId , opts ) await doc . update ( newContent , newMetadata , opts ) Example In this example we update a document's content while also giving it a tag. const streamId = 'kjzl6cwe1jw14...' // Replace this with the StreamID of the TileDocument to be updated const doc = await TileDocument . load ( ceramic , streamId ) await doc . update ({ foo : 'baz' }, { tags : [ 'baz' ] }) API reference Parameters \u00b6 content \u00b6 The new content of your document. This fully replaces any existing content in the document. metadata (optional) \u00b6 Only fields that are provided in the metadata arg will be updated. Fields not specified in the metadata arg will be left with their current value. API reference Updating the deterministic parameter Please note that the deterministic parameter can only be set while creating a document. It cannot be updated once the document exists. opts (optional) \u00b6 The final argument to TileDocument.update is an instance of UpdateOpts , which are options that control network behaviors performed as part of the operation. They are not included in the document itself. Parameter Required? Value Description Default value anchor optional boolean Request an anchor after updating the document true publish optional boolean Publish the update to the network true API reference Load a document \u00b6 Use the TileDocument.load() method to load a single document using its StreamID const streamId = 'kjzl6cwe1jw14...' // Replace this with the StreamID of the TileDocument to be loaded const doc = await TileDocument . load ( ceramic , streamId , opts ) API reference Parameters \u00b6 ceramic \u00b6 When loading a TileDocument, the first parameter is the CeramicAPI used to communicate with the Ceramic node and it is always required. It will either be an instance of Ceramic when using the Core client or an instance of CeramicClient when using the HTTP client. streamId \u00b6 The StreamID or CommitID of the TileDocument to be loaded. When providing the document's StreamID, Ceramic will attempt to load the most recent version of the document from the network. If a CommitID is provided instead, Ceramic will load the document with the version of the contents and metadata from the specific commit specified. The returned TileDocument object will also be marked readonly and cannot be used to perform updates. opts (optional) \u00b6 The final argument to TileDocument.load is an instance of LoadOpts , which are options that control network behaviors performed as part of the operation. Parameter Required? Value Description Default value sync optional enum Controls behavior related to syncing the current document state from the network SyncOptions.PREFER_CACHE syncTimeoutSeconds optional number How long to wait to hear about the current state of the document from the network 3 API reference Query a deterministic document \u00b6 In the create section, we discussed how to create a document with the deterministic parameter set to true. Since this parameter allows us to generate the exact same StreamID if we create two documents with the same initial metadata , it is possible to \"query\" the document using the same TileDocument.create method that we used to initially create it, without needing to know the StreamID before performing the query. Note we are setting the CreateOpts parameters ( anchor and publish ) to false so that we are only loading the document and not publishing any changes to the network. const doc = TileDocument . create ( ceramic , null , { controllers : [ 'did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H' ], family : 'example family' , deterministic : true , }, { anchor : false , publish : false } }) API reference","title":"API"},{"location":"streamtypes/tile-document/api/#tiledocument-api","text":"This guide demonstrates how to create, update, and query TileDocuments on the Ceramic network using the HTTP and core clients. TileDocuments can also be read and written via the CLI, see Quick Start for more information.","title":"TileDocument API"},{"location":"streamtypes/tile-document/api/#prerequisites","text":"You need an installed client and an authenticated user to perform writes to TileDocuments on the network during runtime. If you only wish to query existing TileDocuments then you still need an installed client but it doesn't need to be authenticated.","title":"Prerequisites"},{"location":"streamtypes/tile-document/api/#create-a-document","text":"Use the TileDocument.create() method to create a new document. const doc = await TileDocument . create ( ceramic , content , metadata , opts ) Example In this example we create a document where we set content , schema , controllers , and family . const doc = await TileDocument . create ( ceramic , { foo : \"bar\" }, { controllers : [ ceramic . did . id ], family : \"doc family\" , schema : schemaDoc . commitId , } ) API reference","title":"Create a document"},{"location":"streamtypes/tile-document/api/#parameters","text":"","title":"Parameters"},{"location":"streamtypes/tile-document/api/#update-a-document","text":"Use the doc.update() method to update the content or metadata of an existing TileDocument. const doc = await TileDocument . load ( ceramic , streamId , opts ) await doc . update ( newContent , newMetadata , opts ) Example In this example we update a document's content while also giving it a tag. const streamId = 'kjzl6cwe1jw14...' // Replace this with the StreamID of the TileDocument to be updated const doc = await TileDocument . load ( ceramic , streamId ) await doc . update ({ foo : 'baz' }, { tags : [ 'baz' ] }) API reference","title":"Update a document"},{"location":"streamtypes/tile-document/api/#parameters_1","text":"","title":"Parameters"},{"location":"streamtypes/tile-document/api/#load-a-document","text":"Use the TileDocument.load() method to load a single document using its StreamID const streamId = 'kjzl6cwe1jw14...' // Replace this with the StreamID of the TileDocument to be loaded const doc = await TileDocument . load ( ceramic , streamId , opts ) API reference","title":"Load a document"},{"location":"streamtypes/tile-document/api/#parameters_2","text":"","title":"Parameters"},{"location":"streamtypes/tile-document/api/#query-a-deterministic-document","text":"In the create section, we discussed how to create a document with the deterministic parameter set to true. Since this parameter allows us to generate the exact same StreamID if we create two documents with the same initial metadata , it is possible to \"query\" the document using the same TileDocument.create method that we used to initially create it, without needing to know the StreamID before performing the query. Note we are setting the CreateOpts parameters ( anchor and publish ) to false so that we are only loading the document and not publishing any changes to the network. const doc = TileDocument . create ( ceramic , null , { controllers : [ 'did:key:z6MkfZ6S4NVVTEuts8o5xFzRMR8eC6Y1bngoBQNnXiCvhH8H' ], family : 'example family' , deterministic : true , }, { anchor : false , publish : false } }) API reference","title":"Query a deterministic document"},{"location":"streamtypes/tile-document/overview/","text":"Tile Document \u00b6 Tile Document is a StreamType that stores a JSON document, providing similar functionality as a NoSQL document store. Use cases \u00b6 Tile Document streams are commonly used as a NoSQL database replacement for: Identity metadata (i.e. profiles, social graphs, reputation scores, linked social accounts) User-generated content (i.e. blog posts, social media, etc) Indexes of other streams to form collections and user tables (i.e. IDX) DID documents (i.e. 3ID DID) Verifiable claims And more Design \u00b6 Data structure: Single log Content requirements: JSON Authetication: DIDs Ordering: Anchor records that rely on blockchain checkponting (via blockheight) Conflict resolution: Earliest anchor wins","title":"Overview"},{"location":"streamtypes/tile-document/overview/#tile-document","text":"Tile Document is a StreamType that stores a JSON document, providing similar functionality as a NoSQL document store.","title":"Tile Document"},{"location":"streamtypes/tile-document/overview/#use-cases","text":"Tile Document streams are commonly used as a NoSQL database replacement for: Identity metadata (i.e. profiles, social graphs, reputation scores, linked social accounts) User-generated content (i.e. blog posts, social media, etc) Indexes of other streams to form collections and user tables (i.e. IDX) DID documents (i.e. 3ID DID) Verifiable claims And more","title":"Use cases"},{"location":"streamtypes/tile-document/overview/#design","text":"Data structure: Single log Content requirements: JSON Authetication: DIDs Ordering: Anchor records that rely on blockchain checkponting (via blockheight) Conflict resolution: Earliest anchor wins","title":"Design"},{"location":"streamtypes/tile-document/schemas/basic-profile/","text":"Basic Profile \u00b6 The basic profile schema is used to create a stream that stores basic profile metadata for a DID. It is typically deployed in a Tile Document StreamType, and is one of the default schemas provided in the IDX identity protocol. See CIP-19 for the complete specification. Schema \u00b6 The basic profile schema defines the format of a stream that contains the properties listed below. Properties not defined in the schema cannot be included in the basic profile, however the schema can always by modifying the CIP. Property Description Value Max Size Required Example name a name string 150 char optional Mary Smith image an image Image sources optional description a short description string 420 char optional This is my cool description. emoji an emoji unicode 2 char optional \ud83d\udd22 background a background image (3:1 ratio) Image sources optional birthDate a date of birth ISO 8601 10 char optional 1990-04-24 url a url string 240 char optional http://ceramic.network gender a gender string 42 char optional female residenceCity a city of residence string 140 char optional Berlin residenceCountry a country of residence ISO 3166-1 alpha-2 2 char optional DE nationalities nationalities array of ISO 3166-1 alpha-2 values 2 char optional CN affiliations affiliations array of strings 240 char optional Ceramic Ecosystem Alliance { \"$schema\" : \"http://json-schema.org/draft-07/schema#\" , \"title\" : \"BasicProfile\" , \"type\" : \"object\" , \"definitions\" : { \"IPFSUrl\" : { \"type\" : \"string\" , \"pattern\" : \"^ipfs://.+\" , \"maxLength\" : 150 }, \"positiveInteger\" : { \"type\" : \"integer\" , \"minimum\" : 1 }, \"imageMetadata\" : { \"type\" : \"object\" , \"properties\" : { \"src\" : { \"$ref\" : \"#/definitions/IPFSUrl\" }, \"mimeType\" : { \"type\" : \"string\" , \"maxLength\" : 50 }, \"width\" : { \"$ref\" : \"#/definitions/positiveInteger\" }, \"height\" : { \"$ref\" : \"#/definitions/positiveInteger\" }, \"size\" : { \"$ref\" : \"#/definitions/positiveInteger\" } }, \"required\" : [ \"src\" , \"mimeType\" , \"width\" , \"height\" ] }, \"imageSources\" : { \"type\" : \"object\" , \"properties\" : { \"original\" : { \"$ref\" : \"#/definitions/imageMetadata\" }, \"alternatives\" : { \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/definitions/imageMetadata\" } } }, \"required\" : [ \"original\" ] } }, \"properties\" : { \"name\" : { \"type\" : \"string\" , \"maxLength\" : 150 }, \"image\" : { \"$ref\" : \"#/definitions/imageSources\" }, \"description\" : { \"type\" : \"string\" , \"maxLength\" : 420 }, \"emoji\" : { \"type\" : \"string\" , \"maxLength\" : 2 }, \"background\" : { \"$ref\" : \"#/definitions/imageSources\" }, \"birthDate\" : { \"type\" : \"string\" , \"format\" : \"date\" }, \"url\" : { \"type\" : \"string\" , \"maxLength\" : 240 }, \"gender\" : { \"type\" : \"string\" , \"maxLength\" : 42 }, \"homeLocation\" : { \"type\" : \"string\" , \"maxLength\" : 140 }, \"residenceCountry\" : { \"type\" : \"string\" , \"pattern\" : \"^[A-Z]{2}$\" }, \"nationalities\" : { \"type\" : \"array\" , \"minItems\" : 1 , \"items\" : { \"type\" : \"string\" , \"pattern\" : \"^[A-Z]{2}$\" , \"maxItems\" : 5 } }, \"affiliations\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" , \"maxLength\" : 240 } } } } Usage \u00b6 There are two primary ways to create basic profile streams. With IDX (recommended) \u00b6 IDX is a protocol and SDK that provides a way for developers to build user-centric applications by organizing information around a DID in an application-agnostic way, allowing them to set and get identity records. At its core, IDX functions like a user-centric, decentralized user table shared by all applications which enables maximal interoperability of information. Basic profile is a default schema provided by IDX. See the IDX documentation for how to install IDX in your project. Without IDX \u00b6 You can create streams that conform to the basic profile schema without using IDX, if desired. However, note that without using IDX it will be difficult for your application or other applications to keep track of the StreamIDs of the basic profiles for each of your users. You will need to do this manually. To create a basic profile without using IDX, manually create a Tile Document stream using a Ceramic client and include the StreamID of the basic profile schema in the stream's metadata: k3y52l7qbv1frxt706gqfzmq6cbqdkptzk8uudaryhlkf6ly9vx21hqu4r6k1jqio Example \u00b6 An example of how to create a basic profile stream with js-ceramic. const profile = await ceramic . createDocument ( 'tile' , { metadata : { schema : \"<record-schema-DocID>\" family : \"<definition-DocID>\" }, content : { name : \"Samantha Smith\" , image : { original : { src : \"ipfs://bafy...\" , mimeType : \"image/png\" , width : 500 , height : 200 } }, description : \"This is my funny description.\" , emoji : \"\ud83d\ude80\" , url : \"http://ceramic.network\" } })","title":"BasicProfile"},{"location":"streamtypes/tile-document/schemas/basic-profile/#basic-profile","text":"The basic profile schema is used to create a stream that stores basic profile metadata for a DID. It is typically deployed in a Tile Document StreamType, and is one of the default schemas provided in the IDX identity protocol. See CIP-19 for the complete specification.","title":"Basic Profile"},{"location":"streamtypes/tile-document/schemas/basic-profile/#schema","text":"The basic profile schema defines the format of a stream that contains the properties listed below. Properties not defined in the schema cannot be included in the basic profile, however the schema can always by modifying the CIP. Property Description Value Max Size Required Example name a name string 150 char optional Mary Smith image an image Image sources optional description a short description string 420 char optional This is my cool description. emoji an emoji unicode 2 char optional \ud83d\udd22 background a background image (3:1 ratio) Image sources optional birthDate a date of birth ISO 8601 10 char optional 1990-04-24 url a url string 240 char optional http://ceramic.network gender a gender string 42 char optional female residenceCity a city of residence string 140 char optional Berlin residenceCountry a country of residence ISO 3166-1 alpha-2 2 char optional DE nationalities nationalities array of ISO 3166-1 alpha-2 values 2 char optional CN affiliations affiliations array of strings 240 char optional Ceramic Ecosystem Alliance { \"$schema\" : \"http://json-schema.org/draft-07/schema#\" , \"title\" : \"BasicProfile\" , \"type\" : \"object\" , \"definitions\" : { \"IPFSUrl\" : { \"type\" : \"string\" , \"pattern\" : \"^ipfs://.+\" , \"maxLength\" : 150 }, \"positiveInteger\" : { \"type\" : \"integer\" , \"minimum\" : 1 }, \"imageMetadata\" : { \"type\" : \"object\" , \"properties\" : { \"src\" : { \"$ref\" : \"#/definitions/IPFSUrl\" }, \"mimeType\" : { \"type\" : \"string\" , \"maxLength\" : 50 }, \"width\" : { \"$ref\" : \"#/definitions/positiveInteger\" }, \"height\" : { \"$ref\" : \"#/definitions/positiveInteger\" }, \"size\" : { \"$ref\" : \"#/definitions/positiveInteger\" } }, \"required\" : [ \"src\" , \"mimeType\" , \"width\" , \"height\" ] }, \"imageSources\" : { \"type\" : \"object\" , \"properties\" : { \"original\" : { \"$ref\" : \"#/definitions/imageMetadata\" }, \"alternatives\" : { \"type\" : \"array\" , \"items\" : { \"$ref\" : \"#/definitions/imageMetadata\" } } }, \"required\" : [ \"original\" ] } }, \"properties\" : { \"name\" : { \"type\" : \"string\" , \"maxLength\" : 150 }, \"image\" : { \"$ref\" : \"#/definitions/imageSources\" }, \"description\" : { \"type\" : \"string\" , \"maxLength\" : 420 }, \"emoji\" : { \"type\" : \"string\" , \"maxLength\" : 2 }, \"background\" : { \"$ref\" : \"#/definitions/imageSources\" }, \"birthDate\" : { \"type\" : \"string\" , \"format\" : \"date\" }, \"url\" : { \"type\" : \"string\" , \"maxLength\" : 240 }, \"gender\" : { \"type\" : \"string\" , \"maxLength\" : 42 }, \"homeLocation\" : { \"type\" : \"string\" , \"maxLength\" : 140 }, \"residenceCountry\" : { \"type\" : \"string\" , \"pattern\" : \"^[A-Z]{2}$\" }, \"nationalities\" : { \"type\" : \"array\" , \"minItems\" : 1 , \"items\" : { \"type\" : \"string\" , \"pattern\" : \"^[A-Z]{2}$\" , \"maxItems\" : 5 } }, \"affiliations\" : { \"type\" : \"array\" , \"items\" : { \"type\" : \"string\" , \"maxLength\" : 240 } } } }","title":"Schema"},{"location":"streamtypes/tile-document/schemas/basic-profile/#usage","text":"There are two primary ways to create basic profile streams.","title":"Usage"},{"location":"streamtypes/tile-document/schemas/basic-profile/#with-idx-recommended","text":"IDX is a protocol and SDK that provides a way for developers to build user-centric applications by organizing information around a DID in an application-agnostic way, allowing them to set and get identity records. At its core, IDX functions like a user-centric, decentralized user table shared by all applications which enables maximal interoperability of information. Basic profile is a default schema provided by IDX. See the IDX documentation for how to install IDX in your project.","title":"With IDX (recommended)"},{"location":"streamtypes/tile-document/schemas/basic-profile/#without-idx","text":"You can create streams that conform to the basic profile schema without using IDX, if desired. However, note that without using IDX it will be difficult for your application or other applications to keep track of the StreamIDs of the basic profiles for each of your users. You will need to do this manually. To create a basic profile without using IDX, manually create a Tile Document stream using a Ceramic client and include the StreamID of the basic profile schema in the stream's metadata: k3y52l7qbv1frxt706gqfzmq6cbqdkptzk8uudaryhlkf6ly9vx21hqu4r6k1jqio","title":"Without IDX"},{"location":"tools/networks/","text":"Networks \u00b6 Ceramic is currently available as four different networks for you to use when building and deploying your application. Public Networks \u00b6 Mainnet \u00b6 Ceramic mainnet is the main public network used for the production deployment of applications. Ceramic mainnet nodes communicate over the dedicated /ceramic/mainnet pubsub topic and are capable of anchoring documents on the Ethereum mainnet blockchain ( EIP155:1 ). Ceramic mainnet is scheduled to go live sometime around Q1 2021 . Clay \u00b6 Clay is the main public test network used for the experimental deployment of applications. Clay nodes communicate over the dedicated /ceramic/testnet-clay pubsub topic and are capable of anchoring documents on the Ethereum Rinkeby ( EIP155:? ) and Ethereum Ropsten ( EIP155:? ) testnet blockchains. Clay is available to use now. Development Networks \u00b6 Local \u00b6 Local is a private test network used for the local development of applications. Nodes connected to the same local network communicate over a randomly-generated pubsub topic /ceramic/local-$(randomNumber) and are capable of anchoring documents on a local Ethereum blockchain provided by Truffle's Ganache ( EIP155:? ). In memory \u00b6 In memory is a private...","title":"Networks"},{"location":"tools/networks/#networks","text":"Ceramic is currently available as four different networks for you to use when building and deploying your application.","title":"Networks"},{"location":"tools/networks/#public-networks","text":"","title":"Public Networks"},{"location":"tools/networks/#mainnet","text":"Ceramic mainnet is the main public network used for the production deployment of applications. Ceramic mainnet nodes communicate over the dedicated /ceramic/mainnet pubsub topic and are capable of anchoring documents on the Ethereum mainnet blockchain ( EIP155:1 ). Ceramic mainnet is scheduled to go live sometime around Q1 2021 .","title":"Mainnet"},{"location":"tools/networks/#clay","text":"Clay is the main public test network used for the experimental deployment of applications. Clay nodes communicate over the dedicated /ceramic/testnet-clay pubsub topic and are capable of anchoring documents on the Ethereum Rinkeby ( EIP155:? ) and Ethereum Ropsten ( EIP155:? ) testnet blockchains. Clay is available to use now.","title":"Clay"},{"location":"tools/networks/#development-networks","text":"","title":"Development Networks"},{"location":"tools/networks/#local","text":"Local is a private test network used for the local development of applications. Nodes connected to the same local network communicate over a randomly-generated pubsub topic /ceramic/local-$(randomNumber) and are capable of anchoring documents on a local Ethereum blockchain provided by Truffle's Ganache ( EIP155:? ).","title":"Local"},{"location":"tools/networks/#in-memory","text":"In memory is a private...","title":"In memory"},{"location":"tools/identity/identitylink/","text":"IdentityLink \u00b6 IdentityLink is a service that issues verifiable claims which prove that a DID owns one or more Web2 social accounts. Once issued these claims can be stored anywhere, however it is recommended to store them in a user's IDX under the Also Known As definition. Compatibility \u00b6 DID Methods \u00b6 IdentityLink works with all DID methods. Web2 Platforms \u00b6 IdentityLink currently supports: Twitter Github Discord Discourse Telegram Instagram (coming soon) How it works \u00b6 Public DNS \u00b6 For platforms that allow users to post content to public DNS endpoints (i.e. Twitter, Github): Private servers \u00b6 For platforms that restrict messages to private servers (i.e. Telegram, Discord): Usage \u00b6 Use the IdentityLink service hosted by 3Box Labs \u00b6 Add more about how to add it to your project. Run your own IdentityLink service \u00b6 Point to the relevant instructions on how to run it yourself. Learn more \u00b6 Visit the IdentityLink repository on Github for full documentation.","title":"IdentityLink"},{"location":"tools/identity/identitylink/#identitylink","text":"IdentityLink is a service that issues verifiable claims which prove that a DID owns one or more Web2 social accounts. Once issued these claims can be stored anywhere, however it is recommended to store them in a user's IDX under the Also Known As definition.","title":"IdentityLink"},{"location":"tools/identity/identitylink/#compatibility","text":"","title":"Compatibility"},{"location":"tools/identity/identitylink/#did-methods","text":"IdentityLink works with all DID methods.","title":"DID Methods"},{"location":"tools/identity/identitylink/#web2-platforms","text":"IdentityLink currently supports: Twitter Github Discord Discourse Telegram Instagram (coming soon)","title":"Web2 Platforms"},{"location":"tools/identity/identitylink/#how-it-works","text":"","title":"How it works"},{"location":"tools/identity/identitylink/#public-dns","text":"For platforms that allow users to post content to public DNS endpoints (i.e. Twitter, Github):","title":"Public DNS"},{"location":"tools/identity/identitylink/#private-servers","text":"For platforms that restrict messages to private servers (i.e. Telegram, Discord):","title":"Private servers"},{"location":"tools/identity/identitylink/#usage","text":"","title":"Usage"},{"location":"tools/identity/identitylink/#use-the-identitylink-service-hosted-by-3box-labs","text":"Add more about how to add it to your project.","title":"Use the IdentityLink service hosted by 3Box Labs"},{"location":"tools/identity/identitylink/#run-your-own-identitylink-service","text":"Point to the relevant instructions on how to run it yourself.","title":"Run your own IdentityLink service"},{"location":"tools/identity/identitylink/#learn-more","text":"Visit the IdentityLink repository on Github for full documentation.","title":"Learn more"},{"location":"tools/identity/idx/","text":"IDX \u00b6 IDX is an identity standard for associating any kind of data to a DID. IDX allows you to replace application specific user tables with a decentralized, user-centic alternative. Usage \u00b6 View the IDX documentation to learn how to install IDX in your project. Design \u00b6 Index: Definitions: Records: Learn more \u00b6 Website Documentation Discord community","title":"IDX"},{"location":"tools/identity/idx/#idx","text":"IDX is an identity standard for associating any kind of data to a DID. IDX allows you to replace application specific user tables with a decentralized, user-centic alternative.","title":"IDX"},{"location":"tools/identity/idx/#usage","text":"View the IDX documentation to learn how to install IDX in your project.","title":"Usage"},{"location":"tools/identity/idx/#design","text":"Index: Definitions: Records:","title":"Design"},{"location":"tools/identity/idx/#learn-more","text":"Website Documentation Discord community","title":"Learn more"},{"location":"tools/identity/self-id/","text":"Self.ID (coming soon) \u00b6 Self.ID is a web application that allows users to manage their basic, profile-related IDX records. Usage \u00b6 Design \u00b6 Self.ID integrates with the following standards, tools and services. Authentication \u00b6 3ID Connect: Uses 3ID DID method and allows users to authenticate with their existing blockchain wallets. Identity \u00b6 IDX: IdentityLink: Definitions \u00b6 Basic Profile: 3ID Keychain: Also Known As:","title":"Self.id"},{"location":"tools/identity/self-id/#selfid-coming-soon","text":"Self.ID is a web application that allows users to manage their basic, profile-related IDX records.","title":"Self.ID (coming soon)"},{"location":"tools/identity/self-id/#usage","text":"","title":"Usage"},{"location":"tools/identity/self-id/#design","text":"Self.ID integrates with the following standards, tools and services.","title":"Design"},{"location":"tools/identity/self-id/#authentication","text":"3ID Connect: Uses 3ID DID method and allows users to authenticate with their existing blockchain wallets.","title":"Authentication"},{"location":"tools/identity/self-id/#identity","text":"IDX: IdentityLink:","title":"Identity"},{"location":"tools/identity/self-id/#definitions","text":"Basic Profile: 3ID Keychain: Also Known As:","title":"Definitions"},{"location":"try/explorers/","text":"Explorers \u00b6 Discover various explorers for the Ceramic Network. Tiles \u00b6 Tiles : A browser-based explorer where you can see a feed of all streams created on the network, and dive into the details of any particular stream.","title":"Explorers"},{"location":"try/explorers/#explorers","text":"Discover various explorers for the Ceramic Network.","title":"Explorers"},{"location":"try/explorers/#tiles","text":"Tiles : A browser-based explorer where you can see a feed of all streams created on the network, and dive into the details of any particular stream.","title":"Tiles"},{"location":"try/projects/","text":"Community projects \u00b6 See Awesome Ceramic for a list of community projects built on Ceramic.","title":"Projects"},{"location":"try/projects/#community-projects","text":"See Awesome Ceramic for a list of community projects built on Ceramic.","title":"Community projects"},{"location":"try/sample-apps/","text":"Sample Apps \u00b6 Simple demo applications to give you a sense of what's possible with Ceramic. Playground : A minimal browser application that integrates the Ceramic JS HTTP client, 3ID Connect , and IDX .","title":"Demos"},{"location":"try/sample-apps/#sample-apps","text":"Simple demo applications to give you a sense of what's possible with Ceramic. Playground : A minimal browser application that integrates the Ceramic JS HTTP client, 3ID Connect , and IDX .","title":"Sample Apps"}]}